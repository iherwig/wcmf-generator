«IMPORT uml»
«IMPORT Chronos»


«EXTENSION common::util»
«EXTENSION common::umlutils»

«EXTENSION cartridge::ChiCmf::extensions::ChiNode»
«EXTENSION cartridge::ChiCmf::extensions::util»
«EXTENSION cartridge::Grails::classtools»

«DEFINE root FOR uml::Model»
	«EXPAND domainClass FOREACH this.allOwnedElements().typeSelect(ChiNode).select(e|!e.isManyToMany() && !e.isLibraryClass())»
«ENDDEFINE»

«REM»For the time being, all package references are commented.«ENDREM»

«REM» Main domain root «ENDREM»
«DEFINE domainClass FOR ChiNode»
	«info("Generating " + this.name)»
	«REM»
	«LET this.getNearestPackage().getPackageName() AS fullQualifiedPackage»
	«FILE (!fullQualifiedPackage.isNullOrEmpty() ? fullQualifiedPackage.asPath() + "/" : "") + this.name +".groovy"-»
	«ENDREM»
	«FILE this.name +".groovy"-»
«REM»
«IF !fullQualifiedPackage.isNullOrEmpty()-»
package «fullQualifiedPackage»
«ENDIF-»

	«EXPAND Import FOR this-»
«ENDREM»

/**
 * «this.getComment("\n * ")»
 */
«REM avoiding abstract bug in Grails»«IF this.isAbstract»abstract «ENDIF-»«ENDREM-»
class «name-» 
«IF !this.superClass.select(e|!e.isLibraryClass()).isEmpty» extends «this.superClass.first().name»«ENDIF»
{
	«REM» Attributes «ENDREM-»
«EXPAND Attribute FOREACH this.getOwnChiAttributes()-»

	«REM» Every property where e reference for navigation is stored «ENDREM-»
«EXPAND ReferenceProperties FOR this-»

	«REM» many-to-one parents (1:1 relations are handled as ReferenceProperty)«ENDREM-»
«EXPAND ManyToOneParents FOR this-»

	«REM» one-to-many children (1:1 relations are handled as ReferenceProperty)«ENDREM-»
«EXPAND OneToManyChildren FOR this-»					

	«REM» MappedBy for handling multiple relations between the same Classes «ENDREM-»
«EXPAND MappedBy FOR this-»
					
	«REM» Mapping «ENDREM-»
«EXPAND Mapping FOR this-»

	«REM» Constraints «ENDREM-»
«EXPAND Constraints FOR this-»

	«REM» Methods «ENDREM-»
«EXPAND Method(this) FOREACH ownedOperation-»
}
	«ENDFILE»
	«REM»«ENDLET»«ENDREM»
«ENDDEFINE»	

«DEFINE Import FOR uml::Class-»
	«FOREACH this.getImportedClasses() AS import-»
import «IF !import.getNearestPackage().getPackageName().isNullOrEmpty()»«import.getNearestPackage().getPackageName()».«ENDIF-»
«import.name»;
	«ENDFOREACH-»
«ENDDEFINE»

«DEFINE MappedBy FOR ChiNode-»
«LET {}.addAll(this.getNotAbstractNavigableParentNodes()).addAll(this.getNotAbstractNavigableChildNodes()) AS relatives-»
«IF relatives.size > 0-»
	/*
	static mappedBy = [
«FOREACH relatives AS relative SEPARATOR ","-»
		«relative.getRoleName().toFirstLower().sanitizeType()»«this.getHierarchyRole(relative)»: "«relative.getOtherEnd().getRoleName().toFirstLower().sanitizeType()»«relative.type.getHierarchyRole(relative.getOtherEnd())»"
«ENDFOREACH-»
	]
	*/
«ENDIF-»
«ENDLET-»
«ENDDEFINE»

«DEFINE Mapping FOR ChiNode-»
	static mapping = {
			tablePerHierarchy false
«FOREACH this.getNotAbstractNavigableChildNodes() AS child-»
«LET child.getRoleName().toFirstLower().sanitizeType()+this.getHierarchyRole(child) AS name-»
«IF child.aggregation == AggregationKind::composite-»
			«name»: "create,save-update"
«ELSEIF child.aggregation == AggregationKind::shared-»
			«name»: "save-update"
«ELSE-»
			«name»: "none"
«ENDIF-»
«ENDLET-»
«ENDFOREACH-»
	}
«ENDDEFINE»	

«REM» simple reference «ENDREM»
«DEFINE ReferenceProperties FOR ChiNode-»
«LET {}.addAll(this.getNotAbstractNavigableParentNodes()).addAll(this.getNotAbstractNavigableChildNodes()).select(e|e.association.isOneToOneAssociation()) AS others-»
«IF others.size > 0»
«FOREACH others AS other-»
	«other.type.name.sanitizeType()» «other.getRoleName().toFirstLower().sanitizeType()»«this.getHierarchyRole(other)»
«ENDFOREACH-»
«ENDIF-»
«ENDLET-»
«ENDDEFINE»

«REM» many-to-one parents (1:1 relations are handled as ReferenceProperty)«ENDREM»
«DEFINE ManyToOneParents FOR ChiNode-»
«LET {}
	.addAll(this.getNotAbstractNavigableParentNodes().select(e|!e.association.isOneToOneAssociation()))
	.addAll(this.getNotAbstractNavigableChildNodes().select(e|
		{}.addAll(e.type.getSuperClassesRecursive()).add(e.type).contains(this.getFirstManyToManyChild(e.type))
	))
 AS parents -»
«IF parents.size > 0-»
	static belongsTo = [
	«FOREACH parents AS parent SEPARATOR ","-»
		«parent.getRoleName().toFirstLower().sanitizeType()»«this.getHierarchyRole(parent)»: «parent.type.name»
	«ENDFOREACH-»
	]
«ENDIF-»
«ENDLET-»
«ENDDEFINE»

«REM» one-to-many children (1:1 relations are handled as ReferenceProperty)«ENDREM»
«DEFINE OneToManyChildren FOR ChiNode-»
«LET this.getNotAbstractNavigableChildNodes().select(e|!e.association.isOneToOneAssociation()) AS children-»
«IF children.size > 0»
	static hasMany = [
«FOREACH children AS child SEPARATOR ","-»
		«child.getRoleName().toFirstLower().sanitizeType()»«this.getHierarchyRole(child)»: «child.type.name»
«ENDFOREACH-»
	]
«ENDIF-»
«ENDLET-»
«ENDDEFINE»

«REM» fill constraints for attributes  «ENDREM»
«DEFINE Constraints FOR ChiNode-»
«LET {}.addAll(this.getNotAbstractNavigableParentNodes()).addAll(this.getNotAbstractNavigableChildNodes()) AS constraintAttributes-»
«IF constraintAttributes.size > 0-»
	static constraints = {
	«FOREACH constraintAttributes AS c-»
		«LET {
			c.hasRestrictionsMatch() ? "matches: \"" + c.getTaggedValue("Chronos::ChiValue", "restrictions_match") + "\"" : null,
			c.isNullable() ? "nullable: true" : "nullable: false",
			c.association != null && c.lowerBound() > 0 ? "minSize: " + c.lowerBound() : null,
			c.association != null && c.upperBound() >= 0 ? "maxSize: " + c.upperBound() : null
		}.select(e|e != null)
		AS constraints»
			«c.getPropertyName().sanitizeType()»«this.getHierarchyRole(c)»(
				«FOREACH constraints AS constraint SEPARATOR ", "»«constraint»«ENDFOREACH»
			)
		«ENDLET-»
	«ENDFOREACH-»
	}
«ENDIF-»
«ENDLET-»
«ENDDEFINE»

«REM» simply attribute «ENDREM»
«DEFINE Attribute FOR ChiValue-»
	/**
	 * «this.getComment("\n	 * ")»
	 */
	«this.type.name.sanitizeType()»«IF this.isMultivalued()»[]«ENDIF» «name»«IF !this.^default.isNullOrEmpty()» = «this.type.getValuePrefix()»«this.^default»«this.type.getValuePostfix()»«ENDIF»
	
«ENDDEFINE»

«REM» simple method with protected region «ENDREM»
«DEFINE Method(Class clazz) FOR Operation-»
	/**
	 * «this.getComment("\n	 * ")»
	 */
	«this.returnResult().first().type.name.sanitizeType()» «name»() {
		// Here you are able to implement your own code
		«PROTECT CSTART '/*' CEND '*/' ID this.getId()»
					
		«ENDPROTECT»
	} 
«ENDDEFINE»
