import uml;

extension common::util;

extension cartridge::ModelCompare::modelCompare;


context uml::Association if memberEnd.size == 2 ERROR
	"Difference in multiplicities of " + this.getMeaningfulName() +
	" (this.source: " + this.getSource().lowerBound() + ".." + this.getSource().upperBound() + " mirror.source: " + this.findMirror().getSource(this).lowerBound() + ".." + this.findMirror().getSource(this).upperBound() +
	" (this.target: " + this.getTarget().lowerBound() + ".." + this.getTarget().upperBound() + " mirror.target: " + this.findMirror().getTarget(this).lowerBound() + ".." + this.findMirror().getTarget(this).upperBound():
	let source = this.getSource():
	let target = this.getTarget():
	let mirror = this.findMirror():

	debug("Testing multiplicity of " + this.getMeaningfulName()) ->
	
	mirror != null ? (
		let mirrorSource = mirror.getSource(this):
		let mirrorTarget = mirror.getTarget(this):

		source.type.name != target.type.name ? (
			mirrorSource.lowerBound() == source.lowerBound() &&
			mirrorSource.upperBound() == source.upperBound() &&
			
			mirrorTarget.lowerBound() == target.lowerBound() &&
			mirrorTarget.upperBound() == target.upperBound()
		) : (
			(
				mirrorSource.lowerBound() == source.lowerBound() &&
				mirrorSource.upperBound() == source.upperBound() &&
				
				mirrorTarget.lowerBound() == target.lowerBound() &&
				mirrorTarget.upperBound() == target.upperBound()
			) || (
				mirrorSource.lowerBound() == target.lowerBound() &&
				mirrorSource.upperBound() == target.upperBound() &&
				
				mirrorTarget.lowerBound() == source.lowerBound() &&
				mirrorTarget.upperBound() == source.upperBound()
			)
		)
	) : (
		warn("No mirror found for multiplicity check of " + this.getMeaningfulName()) ->
	
		true
	)
;

context uml::Association if memberEnd.size == 2 ERROR
	"Difference in navigabilities of " + this.getMeaningfulName() +
	" (this.source: " + this.getSource().isNavigable() + " mirror.source: " + this.findMirror().getSource(this).isNavigable() +
	" (this.target: " + this.getTarget().isNavigable() + " mirror.target: " + this.findMirror().getTarget(this).isNavigable():
	let source = this.getSource():
	let target = this.getTarget():
	let mirror = this.findMirror():
	
	debug("Testing navigability of " + this.getMeaningfulName()) ->

	mirror != null ? (
		let mirrorSource = mirror.getSource(this):
		let mirrorTarget = mirror.getTarget(this):

		source.type.name != target.type.name ? (
			mirrorSource.isNavigable() == source.isNavigable() &&
			mirrorTarget.isNavigable() == target.isNavigable()
		) : (
			(
				mirrorSource.isNavigable() == source.isNavigable() &&
				mirrorTarget.isNavigable() == target.isNavigable()
			) || (
				mirrorSource.isNavigable() == target.isNavigable() &&
				mirrorTarget.isNavigable() == source.isNavigable()
			)
		)
	) : (
		warn("No mirror found for navigability check of " + this.getMeaningfulName()) ->

		true
	)
;

context uml::Association if memberEnd.size == 2 ERROR
	"Difference in roleNames of " + this.getMeaningfulName() +
	" (this.source: " + this.getSource().name + " mirror.source: " + this.findMirror().getSource(this).name +
	" (this.target: " + this.getTarget().name + " mirror.target: " + this.findMirror().getTarget(this).name:
	let source = this.getSource():
	let target = this.getTarget():
	let mirror = this.findMirror():
	
	debug("Testing roleNames of " + this.getMeaningfulName()) ->

	mirror != null ? (
		let mirrorSource = mirror.getSource(this):
		let mirrorTarget = mirror.getTarget(this):

		source.type.name != target.type.name ? (
			mirrorSource.name == source.name &&
			mirrorTarget.name == target.name
		) : (
			(
				mirrorSource.name == source.name &&
				mirrorTarget.name == target.name
			) || (
				mirrorSource.name == target.name &&
				mirrorTarget.name == source.name
			)
		)
	) : (
		warn("No mirror found for roleNames check of " + this.getMeaningfulName()) ->

		true
	)
;

context uml::Property if this.association == null ERROR
	"Different type found for " + this.getMeaningfulName() + 
	" (this.type: " + this.type.name + "mirror.type: " + this.findMirror().type.name:
	
	let mirror = this.findMirror():
	
	debug("Testing type of " + this.getMeaningfulName()) ->
	
	mirror != null ? (
		this.type.name == mirror.type.name
	) : (
		warn("No mirror found for type check of " + this.getMeaningfulName()) ->
		
		true
	)
;
