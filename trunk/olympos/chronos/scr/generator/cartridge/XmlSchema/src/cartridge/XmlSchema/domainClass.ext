import uml;
import xmlSchema;

extension org::openarchitectureware::xsd::lib::qname;

extension common::util;
extension common::umlutils;

extension cartridge::XmlSchema::common;

xmlSchema::TopLevelComplexType convertToXsd(uml::Class this, String targetNamespace, List[String] rootElements):
	//(new xmlSchema::TopLevelComplexType).sequence.e
	//(new xmlSchema::ComplexContentType).exten

	let result = new xmlSchema::TopLevelComplexType:
	let sequence = new xmlSchema::ExplicitGroup:
	let allProperties = this.getAllProperties():
	let parentProperties = this.getSuperClass().getAllProperties():
	
	info("Converting Class " + this.name) ->
	
	allProperties.removeAll(allProperties.select(e|
		(!e.name.isNullOrEmpty() && parentProperties.exists(f|e.name == f.name)) ||
		(e.association != null && parentProperties.exists(f|e.type == f.type))
	)) ->
	
	result.setName(this.name.toFirstLower()) ->
	result.setAbstract(this.isAbstract) ->
	
	//allProperties.exists(e|e.class == this) ? (
		sequence.element.addAll(allProperties.convertProperty(targetNamespace, rootElements))
	//) : (
	//	Void
	//) ->
	->
	
	this.superClass.size > 0 && this.superClass.forAll(e|!e.isAbstract) ? (
		let complex = new xmlSchema::ComplexContentType:
		let ext = new xmlSchema::ExtensionType:
		
		ext.setBase(createQName(targetNamespace, this.superClass.first().name)) ->
		ext.setSequence(sequence) ->
		
		complex.setExtension(ext) ->
		
		result.setComplexContent(complex)
	) : (
		result.setSequence(sequence)
	) -> 
	
	result
;


xmlSchema::LocalElement convertProperty(uml::Property this, String targetNamespace, List[String] rootElements):
	//(new xmlSchema::LocalElement).t
	
	let result = new xmlSchema::LocalElement:
	
	info("	Converting Property " + this.name) ->
	
	//result.setMinOccurs(this.getLower()) ->
	result.setMinOccurs(0) ->
	result.setMaxOccurs(this.getUpper() != -1 ? this.getUpper() : parseToQName("unbounded")) ->
	result.setName(this.nameOrType()) ->
	result.setType(((this.association == null) || (rootElements.contains(this.class.name))) ? (
		this.name != "mRID" ? (
			this.type.sanitizeXsdTypes(targetNamespace)
		) : (
			parseToQName("schema:ID")
		)
	) : (
		parseToQName("schema:IDREF")
	)) ->
	
	result
;

xmlSchema::QName sanitizeXsdTypes(uml::Type this, String targetNamespace):
	let result = switch(this.name.toLowerCase()) {
		case "string": "schema:string"
		case "integer": "schema:int"
		case "long": "schema:long"
		case "boolean": "schema:boolean"
		case "bool": "schema:boolean"
		case "float": "schema:float"
		case null: "schema:anyType"
		default: null
	}:
	
	result == null ? (
		createQName(targetNamespace, this.name)
	) : (
		parseToQName(result)
	)
;

String nameOrType(uml::Property this):
	!this.name.isNullOrEmpty() ? (
		this.name.toFirstLower()
	) : (
		this.type.name.toFirstLower()
	)
;

List[uml::Property] getAllProperties(uml::Class this):
	let result = (List[uml::Property]) {}:
	
	//info("Class:" + this.name) ->
	//info("ownAssociationEnds: " + this.getOwnAssociationEnds().type) ->

	!this.isAbstract ? (
		result.addAll(this.attribute) ->
		//info("filtered: " + this.getOwnAssociationEnds().removeDuplicates(result).type) ->
		result.addAll(this.getOwnAssociationEnds().removeDuplicates(result)) ->
		this.getSuperClass().isAbstract ? (
			result.addAll(this.getSuperClass().getOwnAssociationEnds().removeDuplicates(result)) ->
			result.addAll(this.getSuperClass().attribute)
		) : (
			Void
		)
	) : (
		Void
	) ->
	
	//info("result: " + result.type) ->
	//info("result filtered: " + result.toSet().select(e|e.isNavigable()).toList().type) ->
	result.toSet().select(e|e.isNavigable()).toList()
;

List[uml::Property] removeDuplicates(List[uml::Property] this, List[uml::Property] list):
	this.select(e|e.name.isNullOrEmpty() || !list.exists(f|e.name == f.name))
;
