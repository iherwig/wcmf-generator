«IMPORT uml»
«IMPORT Chronos»

«EXTENSION common::util»
«EXTENSION common::umlutils»

«EXTENSION cartridge::GrailsService::grailsService»

«DEFINE root FOR uml::Model»
	«EXPAND grailsService FOREACH this.allOwnedElements().typeSelect(uml::Activity)»
«ENDDEFINE»

«DEFINE grailsService FOR uml::Activity»
	«EXPAND contextClasses FOREACH this.getProductionRulesets()»
	«EXPAND selectionClasses FOREACH this.getDecisionsWithSelection()»
	
	«EXPAND cartridge::GrailsService::jrules::ruleSet FOREACH this.getProductionRulesets()»

	«FILE SERVICE_PACKAGE().packageToPath() + "/" + this.asClassName() + ".groovy" SERVICE»
«groovyFileHeader()»

/* «generatorSignature()» */	
	
package «SERVICE_PACKAGE()»

	«FOREACH this.getProductionRulesets() AS currProductionRuleset»
import «currProductionRuleset.asFullPackageName()».«currProductionRuleset.asContextName()»
	«ENDFOREACH»
	
	«FOREACH this.getDecisionsWithSelection() AS currDecision»
import «currDecision.asFullPackageName()».«currDecision.asSelectionName()»
	«ENDFOREACH»

«PROTECT CSTART "/*" CEND "*/" ID this.fullQualifiedName() + "Imports"» 
/* put additional imports here */
«ENDPROTECT»

/**
 * «this.owner.getComment("\n * ")»
 */
class «this.asClassName()» {
			
	boolean transactional = true
	
	protected «this.asRequestType()» request = «this.asRequestConstructorCall()»
	protected «this.asResultType()» result = «this.asResultConstructorCall()»

	«FOREACH this.node.typeSelect(uml::DataStoreNode).select(e|e == this.node.typeSelect(uml::DataStoreNode).selectFirst(f|e.name == f.name)).select(e|e.incoming.source.incoming.name.first() != "LoopStart") AS currChiObject»
	protected «currChiObject.getGrailsTypeName()» «currChiObject.asVariableName()»
	«ENDFOREACH»

	«PROTECT CSTART "/*" CEND "*/" ID this.fullQualifiedName() + "UndefinedVariables"» 
	/* put additional cross-Activity variables here */
	«ENDPROTECT»

	public «this.asResultType()» «this.asMainMethodName()»(«this.asRequestType()» request) {
		this.request = request
		
		«LET this.getFirstNode() AS firstNode»
			«IF firstNode != null»
				«EXPAND nodeCall FOR this.getFirstNode()»
			«ENDIF»
		«ENDLET»
		
		return this.result
	}
	
	«EXPAND nodeMethod FOREACH this.getMethodNodes().select(e|e.getProductionRuleset() == null)»
	
	«EXPAND nodeMethod FOREACH this.getProductionRulesets()»
}
	«ENDFILE»
«ENDDEFINE»

«DEFINE contextClasses FOR Ouranos::ProductionRuleset»
	«FILE this.asFullPackageName().packageToPath() + "/" + this.asContextName() + ".groovy" CONTEXT»
«groovyFileHeader()»

/* «generatorSignature()» */	
	
package «this.asFullPackageName()»

import com.eenergy.jrules.Context;

«PROTECT CSTART "/*" CEND "*/" ID this.fullQualifiedName() + "Imports"» 
/* put additional imports here */
«ENDPROTECT»

public class «this.asContextName()» extends Context {
	/**
	 * contains constants that define a level of a flow within a ruleset
	 * e.g. these constants are set as a the Result of the execute of a rule
	 */
	enum RulesetState {
		«PROTECT CSTART "/*" CEND "*/" ID this.fullQualifiedName() + "ContextRulesetState"» 
		/* Put additional states here */
		«ENDPROTECT»
		BEGIN,
		END
	}
	/**
	 * contains that define the actions for a higher level flow
	 * between rulesets
	 * e.g. these constants are set as a the Result of the execute of a rule
	 */
	enum FlowState {
		«EXPAND flowStates FOR this»			
	}
	/**
	 * State variables
	 */
	RulesetState rulesetState = RulesetState.BEGIN
	FlowState selection
	/** 
	 * Ruleset in variables 
	 */
	«FOREACH this.getFirstNodes().getInputChiObjects() AS currSource»
		«currSource.getGrailsTypeName()» «currSource.asVariableName()»
	«ENDFOREACH»
	«PROTECT CSTART "/*" CEND "*/" ID this.fullQualifiedName() + "ContextVariables"» 
	/* Put additional variables here */
	«ENDPROTECT»
}
	«ENDFILE»
«ENDDEFINE»

«DEFINE selectionClasses FOR uml::DecisionNode»
	«FILE this.asFullPackageName().packageToPath() + "/" + this.asSelectionName() + ".groovy" CONTEXT»
«groovyFileHeader()»

/* «generatorSignature()» */	
	
package «this.asFullPackageName()»

«PROTECT CSTART "/*" CEND "*/" ID this.fullQualifiedName() + "Imports"» 
/* put additional imports here */
«ENDPROTECT»

/**
 * contains that define the actions for a higher level flow
 * between rulesets
 * e.g. these constants are set as a the Result of the execute of a rule
 */
public enum «this.asSelectionName()» {
	«EXPAND flowStates FOR this»			
}
	«ENDFILE»
«ENDDEFINE»	

«DEFINE flowStates FOR Ouranos::ProductionRuleset»
	«FOREACH this.getFlowStates() AS currOutFlow SEPARATOR ","»
		«currOutFlow.asFlowName()-»
	«ENDFOREACH»
«ENDDEFINE»

«DEFINE flowStates FOR uml::DecisionNode»
	«FOREACH this.getFlowStates() AS currOutFlow SEPARATOR ","»
		«currOutFlow.asFlowName()-»
	«ENDFOREACH»
«ENDDEFINE»

«DEFINE resultVariable FOR uml::ActivityNode»
		def «this.asResultName()»
«ENDDEFINE»

«DEFINE nodeCall FOR uml::OpaqueAction»
	«IF !this.isAlreadyProcessed()»
		«IF this.getProductionRuleset() == null»
			«IF !this.isDecisionPredecessor()»
				«EXPAND nodeCallDefault FOR this»
				
				«LET this.getNextEdges().first() AS nextEdge» 
					«IF nextEdge.name != "LoopContinue"»
						«LET nextEdge.target AS nextNode»
							«IF nextNode != null»
								«EXPAND nodeCall FOR nextNode»
							«ENDIF»
						«ENDLET»
					«ELSE»
						continue
					«ENDIF»
				«ENDLET»
			«ELSE»
				«EXPAND nodeCallDecision FOR ((uml::DecisionNode) this.getNextNode())»
			«ENDIF» 
		«ELSE»
			«EXPAND nodeCall FOR this.getProductionRuleset()»
		«ENDIF»
	«ENDIF»
«ENDDEFINE»

«DEFINE nodeCallDecision FOR uml::DecisionNode»
	«IF !this.isAlreadyProcessed()»
		«IF this.getProductionRuleset() == null»
			«this.asResultName()» = «this.asMethodName()»()
			
			«IF !this.isLoop()»
				«LET this.getMergeNode() AS mergeNode»
					switch («this.asResultName()») {
						«EXPAND nodeCallSelection(this.asSelectionName(), false) FOREACH this.getFlowStates()»
					}
					«IF mergeNode != null»
						«EXPAND nodeCall FOR mergeNode.unmarkProcessed()»
					«ENDIF»
				«ENDLET»
			«ELSE»
				«LET this.getLoopPredecessor().incoming.source.typeSelect(uml::DataStoreNode).first() AS listStore»
					«this.getLoopPredecessor().asMethodName()»()
					
					«LET this.getLoopStart().outgoing.target.typeSelect(uml::DataStoreNode).first() AS listElement»
						«listElement.addKeyword(LIST_ELEMENT_KEYWORD())»
						for («listElement.getGrailsTypeName()» «listElement.asVariableName()» : this.«listStore.asVariableName()») {
							this.«listElement.asVariableName()» = «listElement.asVariableName()»
							
							«EXPAND nodeCall FOR this.getLoopStart().getNextNode()»
						}
					«ENDLET»
				«ENDLET»
			«ENDIF»
		«ELSE»
			«EXPAND nodeCall FOR this.getProductionRuleset()»
		«ENDIF»
	«ENDIF»
«ENDDEFINE»

«DEFINE nodeCall FOR uml::ActivityNode»«REM»Dummy for unhandled cases«ENDREM»«ENDDEFINE»

«DEFINE nodeCall FOR Ouranos::ProductionRuleset»
	«LET this.getRulesetParents().typeSelect(uml::DecisionNode) AS decisions»
		«IF decisions.size == 0»
			«EXPAND nodeCallRuleset FOR this»
		«ELSE»
			«IF decisions.first().isLoop()»
				«EXPAND nodeCallRulesetLoop FOR decisions.first()»
			«ELSE»
				«EXPAND nodeCallRulesetDecision FOR this»
			«ENDIF»
		«ENDIF»
	«ENDLET»
«ENDDEFINE»

«DEFINE nodeCallRuleset FOR Ouranos::ProductionRuleset»
	«LET this.getLastNodes().first() AS lastNode» 
		«this.asMethodName()»()
	
		«IF lastNode.getNextNode() != null»
			«EXPAND nodeCall FOR lastNode.getNextNode()»
		«ENDIF»
	«ENDLET»
«ENDDEFINE»

«DEFINE nodeCallRulesetLoop FOR uml::DecisionNode»
	«IF !this.isAlreadyProcessed()»
		«LET this.getLoopPredecessor().incoming.source.typeSelect(uml::DataStoreNode).first() AS listStore»
			«this.getProductionRuleset().asMethodName()»()
			
			«LET this.getLoopStart().outgoing.target.typeSelect(uml::DataStoreNode).first() AS listElement»
				«listElement.addKeyword(LIST_ELEMENT_KEYWORD()) -> ""»
				for («listElement.getGrailsTypeName()» «listElement.asVariableName()» : this.«listStore.asVariableName()») {
					this.«listElement.asVariableName()» = «listElement.asVariableName()»
				
					«EXPAND nodeCall FOR this.getLoopStart().getNextNode()»
				}
			«ENDLET»
		«ENDLET»
		
		«LET this.outgoing.select(e|e.name != "LoopStart").target.first() AS nextNode»
			«IF nextNode != null»
				«EXPAND nodeCall FOR nextNode»
			«ENDIF»
		«ENDLET»
	«ENDIF»
«ENDDEFINE»

«DEFINE nodeCallRulesetDecision FOR Ouranos::ProductionRuleset»
	«LET this.getFirstNodes().first() AS firstNode»
		«firstNode.asResultName()» = «this.asMethodName()»()

		«LET this.getRulesetParents().typeSelect(uml::DecisionNode).first().getMergeNode() AS mergeNode»
			switch («firstNode.asResultName()») {
				«EXPAND nodeCallSelection(this.asContextName(), true) FOREACH this.getFlowStates()»
			}
			«IF mergeNode != null»
				«EXPAND nodeCall FOR mergeNode.unmarkProcessed()»
			«ENDIF»
		«ENDLET»
	«ENDLET»
«ENDDEFINE»

«DEFINE nodeCallDefault FOR uml::ActivityNode»
	«this.asMethodName()»()
«ENDDEFINE»

«DEFINE nodeCallSelection(String contextName, boolean isRuleset) FOR uml::ActivityEdge»
			case «contextName»«IF isRuleset».FlowState«ENDIF».«this.asFlowName()»:
				«IF this.name != "LoopContinue"»
					«IF !isRuleset»
						«EXPAND nodeCall FOR this.target»
					«ELSE»
						«LET ((List[uml::ActivityNode]) {}
								.add(this.target)
								.addAll(this.target.getNextWithSameProductionRuleset().getNextNode())
							)
							.select(e|e.outgoing.target.first().getProductionRuleset() != this.source.getProductionRuleset()).first() AS target»
							«IF target != null»
								«EXPAND nodeCall FOR target»
							«ENDIF»
						«ENDLET»
					«ENDIF»
					break
				«ELSE»
					continue
				«ENDIF»
«ENDDEFINE»

«DEFINE nodeMethod FOR uml::OpaqueAction»
	«EXPAND nodeMethodHeader(this.getInputChiObjects()) FOR this»
	
	«EXPAND nodeMethodFooter FOR this»
«ENDDEFINE»

«DEFINE nodeMethod FOR uml::DecisionNode»
	«EXPAND nodeMethodHeader(this.getPreviousNode().getInputChiObjects()) FOR this»
	«PROTECT CSTART "/*" CEND "*/" ID this.fullQualifiedName() + "Decision"» 
		/* TODO: Required selection criteria */
		result = «this.asSelectionName()».«this.getFlowStates().first().asFlowName()»
	«ENDPROTECT»	
	«EXPAND nodeMethodFooter FOR this»
«ENDDEFINE»

«DEFINE nodeMethod FOR uml::ActivityNode»«REM»Dummy for unhandled cases«ENDREM»«ENDDEFINE»

«DEFINE nodeMethodHeader(List[uml::DataStoreNode] params) FOR uml::ActivityNode»
	protected «this.asMethodName()»() {
		«IF params.size > 0»
			/* Hint: Expected input values
			 * Note: This list may not be complete
			«FOREACH params AS currInput»
			 * * «currInput.getGrailsTypeName()» «currInput.asVariableName()»
			«ENDFOREACH»
			 */
		«ENDIF»
	
		«PROTECT CSTART "/*" CEND "*/" ID this.fullQualifiedName() + "Implementation"» 
			/*
			 TODO: Implement method according to comment below
			 «this.getComment()»
			 */
			
			«IF this.outgoing.typeSelect(uml::ObjectFlow).size > 0»
				/* Hint: Expected return values
				 * Note: This list may not be complete
				«FOREACH this.outgoing.typeSelect(uml::ObjectFlow).target.typeSelect(uml::DataStoreNode) AS currResult»
				 * * «currResult.getGrailsTypeName()» «currResult.asVariableName()»
				«ENDFOREACH»
				 */
			«ENDIF»
		«ENDPROTECT»
«ENDDEFINE»

«DEFINE nodeMethodFooter FOR uml::ActivityNode»
	}
«ENDDEFINE»

«DEFINE nodeMethod FOR Ouranos::ProductionRuleset»
	protected «this.asContextName()» «this.asMethodName()»() {
		com.eenergy.jrules.JRulesService jrs = com.eenergy.jrules.JRulesService.getInstance();
		«PROTECT CSTART "/*" CEND "*/" ID this.fullQualifiedName() + "RulesetFilename"» 
		def rulesetFileName = 'rules/«this.asFullRuleFilePath()»'
		«ENDPROTECT»
		
		// set input
		«this.asContextName()» context = new «this.asContextName()» (
			«LET this.getFirstNodes().getInputChiObjects() AS inputs»
				«IF inputs.size > 0»
					/* Hint: Expected input values
					 * Note: This list may not be complete
					«FOREACH inputs AS currInput»
					 * * «currInput.getGrailsTypeName()» «currInput.asVariableName()»
					«ENDFOREACH»
					 */
				«ENDIF»
			«ENDLET»
			«PROTECT CSTART "/*" CEND "*/" ID this.fullQualifiedName() + "RulesetVariables"»
			/* Put additional variables here */
			«ENDPROTECT» 
		)

		def unNamedParameters = []
		def namedInParameters = [:]
		«PROTECT CSTART "/*" CEND "*/" ID this.fullQualifiedName() + "AdditionalParameters"» 
		/* Add named and unnamed parameters here
		 * e.g.
		 * unNamedParameters.add(arguments.myValue)
		 * namedInParameters.myParameter = arguments.myValue
		 */
		«ENDPROTECT»
		unNamedParameters.add(context)
				
		// execute ruleset
		def executeResult = ''
		while (context.rulesetState != «this.asContextName()».RulesetState.END) {
			executeResult = jrs.execute(rulesetFileName, unNamedParameters, namedInParameters)
			if (executeResult.'ilog.rules.firedRulesCount' == 0) {
				context.rulesetState = «this.asContextName()».RulesetState.END;
			}
			switch (context.rulesetState) {
				«PROTECT CSTART "/*" CEND "*/" ID this.fullQualifiedName() + "RulesetSwitch"» 
				/* Put code for additional states here */
				case «this.asContextName()».RulesetState.END:
					/* Put code for setting the result here */
					result = context.selection
					break
				«ENDPROTECT»
			}
		}
		return result
	}
«ENDDEFINE»
