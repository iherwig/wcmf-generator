«IMPORT uml»
«IMPORT Chronos»

«EXTENSION common::util»
«EXTENSION common::umlutils»

«EXTENSION cartridge::ChiCmf::extensions::ChiNode»
«EXTENSION cartridge::Grails::classtools»

«DEFINE root FOR uml::Model»
	«EXPAND domainClass FOREACH this.allOwnedElements().typeSelect(ChiNode)»
«ENDDEFINE»

«REM» Main domain root «ENDREM»
«DEFINE domainClass FOR ChiNode»
	«info("Generating " + this.name)»
	«LET this.getNearestPackage().getPackageName() AS fullQualifiedPackage»
	«FILE (!fullQualifiedPackage.isNullOrEmpty() ? fullQualifiedPackage.asPath() + "/" : "") + this.name +".groovy"-»
«IF !fullQualifiedPackage.isNullOrEmpty()-»
package «fullQualifiedPackage»
«ENDIF-»

	«EXPAND Import FOR this-»

/**
 * «this.getComment("\n * ")»
 */
«IF this.isAbstract»abstract «ENDIF-»
class «name-» 
«IF !this.superClass.isEmpty» extends «this.superClass.first().name»«ENDIF»
{
	«REM» Attributes «ENDREM-»
«EXPAND Attribute FOREACH this.getChiValues()-»

	«REM» Every property where e reference for navigation is stored «ENDREM-»
«EXPAND ReferenceProperties FOR this-»

	«REM» one-to-many children (1:1 relations are handled as ReferenceProperty)«ENDREM-»
«EXPAND OneToManyChildren FOR this-»

	«REM» many-to-one parents (1:1 relations are handled as ReferenceProperty)«ENDREM-»
«EXPAND ManyToOneParents FOR this-»

	«REM» MappedBy for handling multiple relations between the same Classes «ENDREM-»
«EXPAND MappedBy FOR this-»

	«REM» Mapping «ENDREM-»
«EXPAND Mapping FOR this-»

	«REM» Constraints «ENDREM-»
«EXPAND Constraints FOR this-»

	«REM» Methods «ENDREM-»
«EXPAND Method(this) FOREACH ownedOperation-»
}
	«ENDFILE»
	«ENDLET»
«ENDDEFINE»	

«DEFINE Import FOR uml::Class-»
	«FOREACH this.getImportedClasses() AS import-»
import «IF !import.getNearestPackage().getPackageName().isNullOrEmpty()»«import.getNearestPackage().getPackageName()».«ENDIF-»
«import.name»;
	«ENDFOREACH-»
«ENDDEFINE»

«DEFINE MappedBy FOR ChiNode-»
«LET {}.addAll(this.getParentNodesRecursive()).addAll(this.getChildNodesRecursive()) AS relatives-»
«IF relatives.size > 0-»
	/*
	static mappedBy = [
«FOREACH relatives AS relative SEPARATOR ","-»
		«relative.getRoleName().toFirstLower().sanitizeType()»«this.getHierarchyRole(relative)»: "«relative.getOtherEnd().getRoleName().toFirstLower().sanitizeType()»«relative.type.getHierarchyRole(relative.getOtherEnd())»"
«ENDFOREACH-»
	]
	*/
«ENDIF-»
«ENDLET-»
«ENDDEFINE»

«DEFINE Mapping FOR ChiNode-»
	static mapping = {
			tablePerHierarchy false
«FOREACH this.getChildNodesRecursive() AS child-»
«LET child.getRoleName().toFirstLower().sanitizeType()+this.getHierarchyRole(child) AS name-»
«IF child.aggregation == AggregationKind::composite-»
			«name»: "create,save-update"
«ELSEIF child.aggregation == AggregationKind::shared-»
			«name»: "save-update"
«ELSE-»
			«name»: "none"
«ENDIF-»
«ENDLET-»
«ENDFOREACH-»
	}
«ENDDEFINE»	

«REM» simple reference «ENDREM»
«DEFINE ReferenceProperties FOR ChiNode-»
«LET {}.addAll(this.getParentNodesRecursive()).addAll(this.getChildNodesRecursive()).select(e|e.association.isOneToOneAssociation()) AS others-»
«IF others.size > 0»
«FOREACH others AS other-»
	«other.type.name.sanitizeType()» «other.getRoleName().toFirstLower().sanitizeType()»«this.getHierarchyRole(other)»
«ENDFOREACH-»
«ENDIF-»
«ENDLET-»
«ENDDEFINE»

«REM» many-to-one parents (1:1 relations are handled as ReferenceProperty)«ENDREM»
«DEFINE ManyToOneParents FOR ChiNode-»
«LET this.getParentNodesRecursive().select(e|!e.association.isOneToOneAssociation()) AS parents-»
«IF parents.size > 0-»
	static belongsTo = [
	«FOREACH parents AS parent SEPARATOR ","-»
		«parent.getRoleName().toFirstLower().sanitizeType()»«this.getHierarchyRole(parent)»: «parent.type.name»
	«ENDFOREACH-»
	]
«ENDIF-»
«ENDLET-»
«ENDDEFINE»

«REM» one-to-many children (1:1 relations are handled as ReferenceProperty)«ENDREM»
«DEFINE OneToManyChildren FOR ChiNode-»
«LET this.getChildNodesRecursive().select(e|!e.association.isOneToOneAssociation()) AS children-»
«IF children.size > 0»
	static hasMany = [
«FOREACH children AS child SEPARATOR ","-»
		«child.getRoleName().toFirstLower().sanitizeType()»«this.getHierarchyRole(child)»: «child.type.name»
«ENDFOREACH-»
	]
«ENDIF-»
«ENDLET-»
«ENDDEFINE»

«REM» fill constraints for attributes  «ENDREM»
«DEFINE Constraints FOR ChiNode-»
«LET {}.addAll(this.getParentNodesRecursive()).addAll(this.getChildNodesRecursive()) AS constraintAttributes-»
«IF constraintAttributes.size > 0-»
	static constraints = {
	«FOREACH constraintAttributes AS c-»
		«LET {
			c.hasRestrictionsMatch() ? "matches: \"" + c.getTaggedValue("Chronos::ChiValue", "restrictions_match") + "\"" : null,
			c.isNullable() ? "nullable: true" : "nullable: false",
			c.association != null && c.lowerBound() >= 0 ? "minSize: " + c.lowerBound() : null,
			c.association != null && c.upperBound() >= 0 ? "maxSize: " + c.upperBound() : null
		}.select(e|e != null)
		AS constraints»
			«c.getPropertyName().sanitizeType()»«this.getHierarchyRole(c)»(
				«FOREACH constraints AS constraint SEPARATOR ", "»«constraint»«ENDFOREACH»
			)
		«ENDLET-»
	«ENDFOREACH-»
	}
«ENDIF-»
«ENDLET-»
«ENDDEFINE»

«REM» simply attribute «ENDREM»
«DEFINE Attribute FOR ChiValue-»
	/**
	 * «this.getComment("\n	 * ")»
	 */
	«this.type.name.sanitizeType()»«IF this.isMultivalued()»[]«ENDIF» «name»«IF !this.^default.isNullOrEmpty()» = «this.^default»«ENDIF»
	
«ENDDEFINE»

«REM» simple method with protected region «ENDREM»
«DEFINE Method(Class clazz) FOR Operation-»
	/**
	 * «this.getComment("\n	 * ")»
	 */
	«this.returnResult().first().type.name.sanitizeType()» «name»() {
		// Here you are able to implement your own code
		«PROTECT CSTART '/*' CEND '*/' ID this.getId()»
					
		«ENDPROTECT»
	} 
«ENDDEFINE»
