«IMPORT uml»
«IMPORT Chronos»

«EXTENSION common::util»
«EXTENSION common::umlutils»

«EXTENSION cartridge::GrailsService::grailsService»

«DEFINE root FOR uml::Model»
	«EXPAND grailsService FOREACH this.allOwnedElements().typeSelect(uml::Activity)»
«ENDDEFINE»

«DEFINE grailsService FOR uml::Activity»
	«EXPAND requestClass FOR this»

	«EXPAND resultClass FOR this»
	
	«EXPAND contextClasses FOREACH this.getProductionRulesets()»
	«EXPAND contextClasses FOREACH this.getMethodNodes().typeSelect(uml::DecisionNode).select(e|e.getProductionRuleset() == null)»

	«FILE this.asClassName() + ".groovy"»
/**
 * «this.getComment("\n * ")»
 */
class «this.asClassName()» {
			
	boolean transactional = true
	
	public «this.asResultName()» «this.asMainMethodName()»(«this.asRequestName()» request) {
		«EXPAND resultVariable FOREACH this.getMethodNodes()»
		
		«this.asResultName()» result = «this.asConstructorCall()»
		
		«LET this.getFirstNode() AS firstNode»
			«IF firstNode != null»
				«EXPAND nodeCall FOR this.getFirstNode()»
			«ENDIF»
		«ENDLET»
		
		return result
	}
	
	«EXPAND nodeMethod FOREACH this.getMethodNodes().select(e|e.getProductionRuleset() == null)»
	
	«EXPAND nodeMethod FOREACH this.getProductionRulesets()»
}
	«ENDFILE»
«ENDDEFINE»

«DEFINE requestClass FOR uml::Activity»
	«IF this.asRequestName() != "def"»
		«FILE this.asRequestName() + ".groovy"»
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAccessType;

@XmlAccessorType(XmlAccessType.FIELD)
public class «this.asRequestName()» {
	«FOREACH this.getInputVariables() AS currInput»
	«currInput.getGrailsTypeName()» «currInput.asVariableName()»
	«ENDFOREACH»
}
		«ENDFILE»
	«ENDIF»
«ENDDEFINE»

«DEFINE resultClass FOR uml::Activity»
	«IF this.asResultName() != "def"»
		«FILE this.asResultName() + ".groovy"»
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAccessType;

@XmlAccessorType(XmlAccessType.FIELD)
public class «this.asResultName()» {
	«FOREACH this.getOutputVariables() AS currOutput»
	«currOutput.getGrailsTypeName()» «currOutput.asVariableName()»
	«ENDFOREACH»
}
		«ENDFILE»
	«ENDIF»
«ENDDEFINE»

«DEFINE contextClasses FOR Ouranos::ProductionRuleset»
	«FILE this.asContextName() + ".groovy"»
public class «this.asContextName()» extends Context {
	/**
	 * contains constants that define a level of a flow within a ruleset
	 * e.g. these constants are set as a the Result of the execute of a rule
	 */
	enum RulesetState {
		«PROTECT CSTART "/*" CEND "*/" ID this.fullQualifiedName() + "ContextRulesetState"» 
			/* Put additional states here */
		«ENDPROTECT»
		
		BEGIN,
		END
	}
	
	/**
	 * contains that define the actions for a higher level flow
	 * between rulesets
	 * e.g. these constants are set as a the Result of the execute of a rule
	 */
	enum FlowState {
		«EXPAND flowStates FOR this»			
	}
	
	FlowState selection
	
	RulesetState rulesetState = RulesetState.BEGIN
	
	/* Ruleset in variables */
	«FOREACH this.getFirstNodes().getInputChiObjects() AS currSource»
		«currSource.getGrailsTypeName()» «currSource.asVariableName()»
	«ENDFOREACH»
}
	«ENDFILE»
«ENDDEFINE»

«DEFINE contextClasses FOR uml::DecisionNode»
	«FILE this.asContextName() + ".groovy"»
public class «this.asContextName()» extends Context {
	/**
	 * contains that define the actions for a higher level flow
	 * between rulesets
	 * e.g. these constants are set as a the Result of the execute of a rule
	 */
	enum FlowState {
		«EXPAND flowStates FOR this»			
	}
	
	FlowState selection
}
	«ENDFILE»
«ENDDEFINE»	

«DEFINE flowStates FOR Ouranos::ProductionRuleset»
	«FOREACH this.getFlowStates() AS currOutFlow SEPARATOR ","»
		«currOutFlow.asFlowName()-»
	«ENDFOREACH»
«ENDDEFINE»

«DEFINE flowStates FOR uml::DecisionNode»
	«FOREACH this.getFlowStates() AS currOutFlow SEPARATOR ","»
		«currOutFlow.asFlowName()-»
	«ENDFOREACH»
«ENDDEFINE»

«DEFINE resultVariable FOR uml::ActivityNode»
		def «this.asResultName()»
«ENDDEFINE»

«DEFINE nodeCall FOR uml::OpaqueAction»
	«IF !this.isAlreadyProcessed()»
		«IF this.getProductionRuleset() == null»
			«EXPAND nodeCallDefault FOR this»
			
			«EXPAND nodeCallResult FOR this»
		
			«LET this.getNextEdges().first() AS nextEdge» 
				«IF nextEdge.name != "LoopContinue"»
					«LET nextEdge.target AS nextNode»
						«IF nextNode != null»
							«EXPAND nodeCall FOR nextNode»
						«ENDIF»
					«ENDLET»
				«ELSE»
					continue
				«ENDIF»
			«ENDLET»
		«ELSE»
			«EXPAND nodeCall FOR this.getProductionRuleset()»
		«ENDIF»
	«ENDIF»
«ENDDEFINE»

«DEFINE nodeCall FOR uml::DecisionNode»
	«IF !this.isAlreadyProcessed()»
		«IF this.getProductionRuleset() == null»
			«EXPAND nodeCallDefault FOR this»
			
			«IF !this.isLoop()»
				switch («this.asResultName()».selection) {
					«EXPAND nodeCallSelection(this.asContextName(), false) FOREACH this.getFlowStates()»
				}
			«ELSE»
				«LET this.getLoopPredecessor().incoming.source.typeSelect(uml::DataStoreNode).first() AS listStore»
					«listStore.getGrailsTypeName()» «listStore.asVariableName()» = «this.getLoopPredecessor().asMethodName()»(«EXPAND nodeCallParameter FOREACH this.getLoopPredecessor().getInputChiObjects()»)
					
					«LET this.getLoopStart().outgoing.target.typeSelect(uml::DataStoreNode).first() AS listElement»
						«listElement.addKeyword(LIST_ELEMENT_KEYWORD())»
						for («listElement.getGrailsTypeName()» «listElement.asVariableName()» : «listStore.asVariableName()») {
							«EXPAND nodeCall FOR this.getLoopStart().getNextNode()»
						}
					«ENDLET»
				«ENDLET»
			«ENDIF»
			
			«EXPAND nodeCallResult FOR this»
		«ELSE»
			«EXPAND nodeCall FOR this.getProductionRuleset()»
		«ENDIF»
	«ENDIF»
«ENDDEFINE»

«DEFINE nodeCall FOR uml::ActivityNode»«REM»Dummy for unhandled cases«ENDREM»«ENDDEFINE»

«DEFINE nodeCall FOR Ouranos::ProductionRuleset»
	«LET this.getRulesetParents().typeSelect(uml::DecisionNode) AS decisions»
		«IF decisions.size == 0»
			«EXPAND nodeCallRuleset FOR this»
		«ELSE»
			«IF decisions.first().isLoop()»
				«EXPAND nodeCallRulesetLoop FOR decisions.first()»
			«ELSE»
				«EXPAND nodeCallRulesetDecision FOR this»
			«ENDIF»
		«ENDIF»
	«ENDLET»
«ENDDEFINE»

«DEFINE nodeCallRuleset FOR Ouranos::ProductionRuleset»
	«LET this.getLastNodes().first() AS lastNode» 
		«lastNode.asResultName()» = «this.asMethodName()»(«EXPAND nodeCallParameter FOREACH this.getFirstNodes().getInputChiObjects()»)
	
		«EXPAND nodeCallResult FOR lastNode»
	
		«IF lastNode.getNextNode() != null»
			«EXPAND nodeCall FOR lastNode.getNextNode()»
		«ENDIF»
	«ENDLET»
«ENDDEFINE»

«DEFINE nodeCallRulesetLoop FOR uml::DecisionNode»
	«LET this.getLoopPredecessor().incoming.source.typeSelect(uml::DataStoreNode).first() AS listStore»
		«listStore.getGrailsTypeName()» «listStore.asVariableName()» = «this.getProductionRuleset().asMethodName()»(«EXPAND nodeCallParameter FOREACH this.getLoopPredecessor().getInputChiObjects()»)
		
		«LET this.getLoopStart().outgoing.target.typeSelect(uml::DataStoreNode).first() AS listElement»
			«listElement.addKeyword(LIST_ELEMENT_KEYWORD()) -> ""»
			for («listElement.getGrailsTypeName()» «listElement.asVariableName()» : «listStore.asVariableName()») {
				«EXPAND nodeCall FOR this.getLoopStart().getNextNode()»
			}
		«ENDLET»
	«ENDLET»
	
	«LET this.outgoing.select(e|e.name != "LoopStart").target.first() AS nextNode»
		«IF nextNode != null»
			«EXPAND nodeCall FOR nextNode»
		«ENDIF»
	«ENDLET»
«ENDDEFINE»

«DEFINE nodeCallRulesetDecision FOR Ouranos::ProductionRuleset»
	«LET this.getFirstNodes().first() AS firstNode»
		«firstNode.asResultName()» = «this.asMethodName()»(«EXPAND nodeCallParameter FOREACH firstNode.getInputChiObjects()»)

		switch («firstNode.asResultName()».selection) {
			«EXPAND nodeCallSelection(this.asContextName(), true) FOREACH this.getFlowStates()»
		}
	«ENDLET»
«ENDDEFINE»

«DEFINE nodeCallDefault FOR uml::ActivityNode»
	«this.asResultName()» = «this.asMethodName()»(«EXPAND nodeCallParameter FOREACH this.getInputChiObjects()»)
«ENDDEFINE»

«DEFINE nodeCallParameter FOR uml::DataStoreNode»
	«this.asVariableName()»: «this.getSourceVariableName()»
«ENDDEFINE»

«DEFINE nodeCallResult FOR uml::ActivityNode»
	«FOREACH this.outgoing.typeSelect(uml::ObjectFlow).target.typeSelect(uml::DataStoreNode).select(e|e.outgoing.typeSelect(uml::ObjectFlow).target.outgoing.size == 0) AS currResult»
		result = «this.asResultName()».«currResult.asVariableName()»
	«ENDFOREACH»
«ENDDEFINE»

«DEFINE nodeCallSelection(String contextName, boolean isRuleset) FOR uml::ActivityEdge»
			case «contextName».FlowState.«this.asFlowName()»:
				«IF this.name != "LoopContinue"»
					«IF !isRuleset»
						«EXPAND nodeCall FOR this.target»
					«ELSE»
						«LET ((List[uml::ActivityNode]) {}
								.add(this.target)
								.addAll(this.target.getNextWithSameProductionRuleset())
							)
							.select(e|e.outgoing.target.first().getProductionRuleset() != this.source.getProductionRuleset()).first().getNextNode() AS target»
							«IF target != null»
								«EXPAND nodeCall FOR target»
							«ENDIF»
						«ENDLET»
					«ENDIF»
					break
				«ELSE»
					continue
				«ENDIF»
«ENDDEFINE»

«DEFINE nodeMethod FOR uml::OpaqueAction»
	«EXPAND nodeMethodHeader FOR this»
	
	«EXPAND nodeMethodFooter FOR this»
«ENDDEFINE»

«DEFINE nodeMethod FOR uml::DecisionNode»
	«EXPAND nodeMethodHeader FOR this»
	«PROTECT CSTART "/*" CEND "*/" ID this.fullQualifiedName() + "Decision"» 
		/* TODO: Required selection criteria */
		result.selection = «this.asContextName()».FlowState.«this.getFlowStates().first().asFlowName()»
	«ENDPROTECT»	
	«EXPAND nodeMethodFooter FOR this»
«ENDDEFINE»

«DEFINE nodeMethod FOR uml::ActivityNode»«REM»Dummy for unhandled cases«ENDREM»«ENDDEFINE»

«DEFINE nodeMethodHeader FOR uml::ActivityNode»
	protected «this.asMethodName()»(arguments) {
		«EXPAND nodeMethodInput FOREACH this.getInputChiObjects()»
	
		def result = [:]
		«PROTECT CSTART "/*" CEND "*/" ID this.fullQualifiedName() + "Implementation"» 
			/*
			 TODO: Implement method according to comment below
			 «this.getComment()»
			 */
			
			«IF this.outgoing.typeSelect(uml::ObjectFlow).size > 0»
				/* TODO: Required return values */
				«FOREACH this.outgoing.typeSelect(uml::ObjectFlow).target.typeSelect(uml::DataStoreNode) AS currResult»
					result.«currResult.asVariableName()» = null
				«ENDFOREACH»
			«ENDIF»
		«ENDPROTECT»
«ENDDEFINE»

«DEFINE nodeMethodFooter FOR uml::ActivityNode»
		return result
	}
«ENDDEFINE»

«DEFINE nodeMethodInput FOR uml::DataStoreNode»
	«this.getGrailsTypeName()» «this.asVariableName()» = arguments.«this.asVariableName()»
«ENDDEFINE»


«DEFINE nodeMethod FOR Ouranos::ProductionRuleset»
	protected «this.asContextName()» «this.asMethodName()»(arguments) {
		JRulesService jrs = new JRulesService()
		// define a result Map
		def result = [:]
		
		«PROTECT CSTART "/*" CEND "*/" ID this.fullQualifiedName() + "RulesetFilename"» 
		def rulesetFileName = 'rules/verbrauchsprognoseFuerNaechstenZeitslotPruefen.irl'
		«ENDPROTECT»
		println "#### Run ruleset: $rulesetFileName"
		def ruleSetString = new File(rulesetFileName).getText()
		def cl = this.getClass().getClassLoader()
		def a = jrs.parseNewRuleset(ruleSetString, cl)
		if (!a) {
			throw new RuntimeException ("Error on parsing ruleset $rulesetFileName");
			return
		}
		
		// set input
		// For all ruels, set the input variables and the start state before the while loop
		
		«this.asContextName()» context = new «this.asContextName()» (
			«FOREACH this.getFirstNodes().getInputChiObjects() AS currSource SEPARATOR ", "»
				«currSource.asVariableName()»: «currSource.asVariableName()-»
			«ENDFOREACH»
		)

		def executeResult = ''
		while (context.rulesetState != «this.asContextName()».RulesetState.END) {
			jrs.unNamedParameter = [context]
			
			executeResult = jrs.execute()
			
			if (executeResult.'ilog.rules.firedRulesCount' == 0) {
				context.rulesetState = «this.asContextName()».RulesetState.END;
			}
			
			switch (context.rulesetState) {
				«PROTECT CSTART "/*" CEND "*/" ID this.fullQualifiedName() + "RulesetSwitch"» 
				case «this.asContextName()».RulesetState.END:
					/*
					Handle result, input and output of rules like:
					if (context.alphaResult) {
						result.selection = context.alphaResult
						result.verbrauchsPrognoseMenge = context.alphaBetaVerbrauchsPrognose.menge
						result.nextTimeSlotStart = nextTimeSlot.from
						context.alphaResult = null
					}
					if (context.betaResult) {
						result.selection = context.betaResult
						result.verbrauchsPrognoseWert = 0.0
						context.betaResult = null
					}
					*/
					break
				«ENDPROTECT»
			}
		}

		return result
	}
«ENDDEFINE»
