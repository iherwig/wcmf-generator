«IMPORT uml»
«IMPORT Chronos»

«EXTENSION common::util»
«EXTENSION common::umlutils»

«EXTENSION cartridge::GrailsService::grailsService»

«DEFINE root FOR uml::Model»
	«EXPAND grailsService FOREACH this.allOwnedElements().typeSelect(uml::Activity)»
«ENDDEFINE»

«DEFINE grailsService FOR uml::Activity»
	«REM»
	«EXPAND requestClass FOR this»

	«EXPAND resultClass FOR this»
	«ENDREM»
	
	«EXPAND contextClasses FOREACH this.getProductionRulesets()»
	«EXPAND contextClasses FOREACH this.getDecisionsWithContext()»
	
	«EXPAND cartridge::GrailsService::jrules::ruleSet FOREACH this.getProductionRulesets()»

	«FILE SERVICE_PACKAGE().packageToPath() + "/" + this.asClassName() + ".groovy" SERVICE»
«groovyFileHeader()»

/* «generatorSignature()» */	
	
package «SERVICE_PACKAGE()»

	«FOREACH this.getProductionRulesets() AS currProductionRuleset»
import «currProductionRuleset.asFullPackageName()».«currProductionRuleset.asContextName()»
	«ENDFOREACH»
	
	«FOREACH this.getDecisionsWithContext() AS currDecision»
import «currDecision.asFullPackageName()».«currDecision.asContextName()»
	«ENDFOREACH»

«PROTECT CSTART "/*" CEND "*/" ID this.fullQualifiedName() + "Imports"» 
/* put additional imports here */
«ENDPROTECT»

/**
 * «this.owner.getComment("\n * ")»
 */
class «this.asClassName()» {
			
	boolean transactional = true
	
	public «this.asResultName()» «this.asMainMethodName()»(«this.asRequestName()» request) {
		«EXPAND resultVariable FOREACH this.getMethodNodes()»
		
		«this.asResultName()» result = «this.asConstructorCall()»
		
		«LET this.getFirstNode() AS firstNode»
			«IF firstNode != null»
				«EXPAND nodeCall FOR this.getFirstNode()»
			«ENDIF»
		«ENDLET»
		
		return result
	}
	
	«EXPAND nodeMethod FOREACH this.getMethodNodes().select(e|e.getProductionRuleset() == null)»
	
	«EXPAND nodeMethod FOREACH this.getProductionRulesets()»
}
	«ENDFILE»
«ENDDEFINE»

«REM»
«DEFINE requestClass FOR uml::Activity»
	«IF this.asRequestName() != ""»
		«FILE this.asRequestName() + ".groovy"»
public class «this.asRequestName()» {
	«FOREACH this.getInputVariables() AS currInput»
	«currInput.getGrailsTypeName()» «currInput.asVariableName()»
	«ENDFOREACH»
}
		«ENDFILE»
	«ENDIF»
«ENDDEFINE»

«DEFINE resultClass FOR uml::Activity»
	«IF this.asResultName() != "def"»
		«FILE this.asResultName() + ".groovy"»
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAccessType;

@XmlAccessorType(XmlAccessType.FIELD)
public class «this.asResultName()» {
	«FOREACH this.getOutputVariables() AS currOutput»
	«currOutput.getGrailsTypeName()» «currOutput.asVariableName()»
	«ENDFOREACH»
}
		«ENDFILE»
	«ENDIF»
«ENDDEFINE»
«ENDREM»

«DEFINE contextClasses FOR Ouranos::ProductionRuleset»
	«FILE this.asFullPackageName().packageToPath() + "/" + this.asContextName() + ".groovy" CONTEXT»
«groovyFileHeader()»

/* «generatorSignature()» */	
	
package «this.asFullPackageName()»

import com.eenergy.jrules.Context;

«PROTECT CSTART "/*" CEND "*/" ID this.fullQualifiedName() + "Imports"» 
/* put additional imports here */
«ENDPROTECT»

public class «this.asContextName()» extends Context {
	/**
	 * contains constants that define a level of a flow within a ruleset
	 * e.g. these constants are set as a the Result of the execute of a rule
	 */
	enum RulesetState {
		«PROTECT CSTART "/*" CEND "*/" ID this.fullQualifiedName() + "ContextRulesetState"» 
		/* Put additional states here */
		«ENDPROTECT»
		BEGIN,
		END
	}
	/**
	 * contains that define the actions for a higher level flow
	 * between rulesets
	 * e.g. these constants are set as a the Result of the execute of a rule
	 */
	enum FlowState {
		«EXPAND flowStates FOR this»			
	}
	/**
	 * State variables
	 */
	RulesetState rulesetState = RulesetState.BEGIN
	FlowState selection
	/** 
	 * Ruleset in variables 
	 */
	«FOREACH this.getFirstNodes().getInputChiObjects() AS currSource»
		«currSource.getGrailsTypeName()» «currSource.asVariableName()»
	«ENDFOREACH»
	«PROTECT CSTART "/*" CEND "*/" ID this.fullQualifiedName() + "ContextVariables"» 
	/* Put additional variables here */
	«ENDPROTECT»
}
	«ENDFILE»
«ENDDEFINE»

«DEFINE contextClasses FOR uml::DecisionNode»
	«FILE this.asFullPackageName().packageToPath() + "/" + this.asContextName() + ".groovy" CONTEXT»
«groovyFileHeader()»

/* «generatorSignature()» */	
	
package «this.asFullPackageName()»

import com.eenergy.service.Context

«PROTECT CSTART "/*" CEND "*/" ID this.fullQualifiedName() + "Imports"» 
/* put additional imports here */
«ENDPROTECT»

public class «this.asContextName()» extends Context {
	/**
	 * contains that define the actions for a higher level flow
	 * between rulesets
	 * e.g. these constants are set as a the Result of the execute of a rule
	 */
	enum FlowState {
		«EXPAND flowStates FOR this»			
	}
	
	FlowState selection
}
	«ENDFILE»
«ENDDEFINE»	

«DEFINE flowStates FOR Ouranos::ProductionRuleset»
	«FOREACH this.getFlowStates() AS currOutFlow SEPARATOR ","»
		«currOutFlow.asFlowName()-»
	«ENDFOREACH»
«ENDDEFINE»

«DEFINE flowStates FOR uml::DecisionNode»
	«FOREACH this.getFlowStates() AS currOutFlow SEPARATOR ","»
		«currOutFlow.asFlowName()-»
	«ENDFOREACH»
«ENDDEFINE»

«DEFINE resultVariable FOR uml::ActivityNode»
		def «this.asResultName()»
«ENDDEFINE»

«DEFINE nodeCall FOR uml::OpaqueAction»
	«IF !this.isAlreadyProcessed()»
		«IF this.getProductionRuleset() == null»
			«IF !uml::DecisionNode.isInstance(this.getNextNode())»
				«EXPAND nodeCallDefault FOR this»
				
				«EXPAND nodeCallResult FOR this»
			
				«LET this.getNextEdges().first() AS nextEdge» 
					«IF nextEdge.name != "LoopContinue"»
						«LET nextEdge.target AS nextNode»
							«IF nextNode != null»
								«EXPAND nodeCall FOR nextNode»
							«ENDIF»
						«ENDLET»
					«ELSE»
						continue
					«ENDIF»
				«ENDLET»
			«ELSE»
				«EXPAND nodeCallDecision(this.getInputChiObjects()) FOR ((uml::DecisionNode) this.getNextNode())»
			«ENDIF» 
		«ELSE»
			«EXPAND nodeCall FOR this.getProductionRuleset()»
		«ENDIF»
	«ENDIF»
«ENDDEFINE»

«DEFINE nodeCall FOR uml::DecisionNode»
	«EXPAND nodeCallDecision(this.getInputChiObjects()) FOR this»
«ENDDEFINE»

«DEFINE nodeCallDecision(List[uml::DataStoreNode] params) FOR uml::DecisionNode»
	«IF !this.isAlreadyProcessed()»
		«IF this.getProductionRuleset() == null»
			«EXPAND nodeCallDefault(params) FOR this»
			
			«IF !this.isLoop()»
				switch («this.asResultName()».selection) {
					«EXPAND nodeCallSelection(this.asContextName(), false) FOREACH this.getFlowStates()»
				}
			«ELSE»
				«LET this.getLoopPredecessor().incoming.source.typeSelect(uml::DataStoreNode).first() AS listStore»
					«listStore.getGrailsTypeName()» «listStore.asVariableName()» = «this.getLoopPredecessor().asMethodName()»(«EXPAND nodeCallParameter FOREACH this.getLoopPredecessor().getInputChiObjects()»)
					
					«LET this.getLoopStart().outgoing.target.typeSelect(uml::DataStoreNode).first() AS listElement»
						«listElement.addKeyword(LIST_ELEMENT_KEYWORD())»
						for («listElement.getGrailsTypeName()» «listElement.asVariableName()» : «listStore.asVariableName()») {
							«EXPAND nodeCall FOR this.getLoopStart().getNextNode()»
						}
					«ENDLET»
				«ENDLET»
			«ENDIF»
			
			«EXPAND nodeCallResult FOR this»
		«ELSE»
			«EXPAND nodeCall FOR this.getProductionRuleset()»
		«ENDIF»
	«ENDIF»
«ENDDEFINE»

«DEFINE nodeCall FOR uml::ActivityNode»«REM»Dummy for unhandled cases«ENDREM»«ENDDEFINE»

«DEFINE nodeCall FOR Ouranos::ProductionRuleset»
	«LET this.getRulesetParents().typeSelect(uml::DecisionNode) AS decisions»
		«IF decisions.size == 0»
			«EXPAND nodeCallRuleset FOR this»
		«ELSE»
			«IF decisions.first().isLoop()»
				«EXPAND nodeCallRulesetLoop FOR decisions.first()»
			«ELSE»
				«EXPAND nodeCallRulesetDecision FOR this»
			«ENDIF»
		«ENDIF»
	«ENDLET»
«ENDDEFINE»

«DEFINE nodeCallRuleset FOR Ouranos::ProductionRuleset»
	«LET this.getLastNodes().first() AS lastNode» 
		«lastNode.asResultName()» = «this.asMethodName()»(«EXPAND nodeCallParameter FOREACH this.getFirstNodes().getInputChiObjects()»)
	
		«EXPAND nodeCallResult FOR lastNode»
	
		«IF lastNode.getNextNode() != null»
			«EXPAND nodeCall FOR lastNode.getNextNode()»
		«ENDIF»
	«ENDLET»
«ENDDEFINE»

«DEFINE nodeCallRulesetLoop FOR uml::DecisionNode»
	«IF !this.isAlreadyProcessed()»
		«LET this.getLoopPredecessor().incoming.source.typeSelect(uml::DataStoreNode).first() AS listStore»
			«listStore.getGrailsTypeName()» «listStore.asVariableName()» = «this.getProductionRuleset().asMethodName()»(«EXPAND nodeCallParameter FOREACH this.getLoopPredecessor().getPreviousNode().getInputChiObjects()»)
			
			«LET this.getLoopStart().outgoing.target.typeSelect(uml::DataStoreNode).first() AS listElement»
				«listElement.addKeyword(LIST_ELEMENT_KEYWORD()) -> ""»
				for («listElement.getGrailsTypeName()» «listElement.asVariableName()» : «listStore.asVariableName()») {
					«EXPAND nodeCall FOR this.getLoopStart().getNextNode()»
				}
			«ENDLET»
		«ENDLET»
		
		«LET this.outgoing.select(e|e.name != "LoopStart").target.first() AS nextNode»
			«IF nextNode != null»
				«EXPAND nodeCall FOR nextNode»
			«ENDIF»
		«ENDLET»
	«ENDIF»
«ENDDEFINE»

«DEFINE nodeCallRulesetDecision FOR Ouranos::ProductionRuleset»
	«LET this.getFirstNodes().first() AS firstNode»
		«firstNode.asResultName()» = «this.asMethodName()»(«EXPAND nodeCallParameter FOREACH firstNode.getInputChiObjects()»)

		switch («firstNode.asResultName()».selection) {
			«EXPAND nodeCallSelection(this.asContextName(), true) FOREACH this.getFlowStates()»
		}
	«ENDLET»
«ENDDEFINE»

«DEFINE nodeCallDefault FOR uml::ActivityNode»
	«EXPAND nodeCallDefault(this.getInputChiObjects()) FOR this»
«ENDDEFINE»

«DEFINE nodeCallDefault(List[uml::DataStoreNode] params) FOR uml::ActivityNode»
	«this.asResultName()» = «this.asMethodName()»(«EXPAND nodeCallParameter FOREACH params»)
«ENDDEFINE»

«DEFINE nodeCallParameter FOR uml::DataStoreNode»
	«this.asVariableName()»: «this.getSourceVariableName()»
«ENDDEFINE»

«DEFINE nodeCallResult FOR uml::ActivityNode»
	«FOREACH this.outgoing.typeSelect(uml::ObjectFlow).target.typeSelect(uml::DataStoreNode).select(e|e.outgoing.typeSelect(uml::ObjectFlow).target.outgoing.size == 0) AS currResult»
		result = «this.asResultName()».«currResult.asVariableName()»
	«ENDFOREACH»
«ENDDEFINE»

«DEFINE nodeCallSelection(String contextName, boolean isRuleset) FOR uml::ActivityEdge»
			case «contextName».FlowState.«this.asFlowName()»:
				«IF this.name != "LoopContinue"»
					«IF !isRuleset»
						«EXPAND nodeCall FOR this.target»
					«ELSE»
						«LET ((List[uml::ActivityNode]) {}
								.add(this.target)
								.addAll(this.target.getNextWithSameProductionRuleset().getNextNode())
							)
							.select(e|e.outgoing.target.first().getProductionRuleset() != this.source.getProductionRuleset()).first() AS target»
							«IF target != null»
								«EXPAND nodeCall FOR target»
							«ENDIF»
						«ENDLET»
					«ENDIF»
					break
				«ELSE»
					continue
				«ENDIF»
«ENDDEFINE»

«DEFINE nodeMethod FOR uml::OpaqueAction»
	«EXPAND nodeMethodHeader FOR this»
	
	«EXPAND nodeMethodFooter FOR this»
«ENDDEFINE»

«DEFINE nodeMethod FOR uml::DecisionNode»
	«EXPAND nodeMethodHeader FOR this»
	«PROTECT CSTART "/*" CEND "*/" ID this.fullQualifiedName() + "Decision"» 
		/* TODO: Required selection criteria */
		result.selection = «this.asContextName()».FlowState.«this.getFlowStates().first().asFlowName()»
	«ENDPROTECT»	
	«EXPAND nodeMethodFooter FOR this»
«ENDDEFINE»

«DEFINE nodeMethod FOR uml::ActivityNode»«REM»Dummy for unhandled cases«ENDREM»«ENDDEFINE»

«DEFINE nodeMethodHeader FOR uml::ActivityNode»
	protected «this.asMethodName()»(arguments) {
		«EXPAND nodeMethodInput FOREACH this.getInputChiObjects()»
	
		def result = [:]
		«PROTECT CSTART "/*" CEND "*/" ID this.fullQualifiedName() + "Implementation"» 
			/*
			 TODO: Implement method according to comment below
			 «this.getComment()»
			 */
			
			«IF this.outgoing.typeSelect(uml::ObjectFlow).size > 0»
				/* TODO: Required return values */
				«FOREACH this.outgoing.typeSelect(uml::ObjectFlow).target.typeSelect(uml::DataStoreNode) AS currResult»
					result.«currResult.asVariableName()» = null
				«ENDFOREACH»
			«ENDIF»
		«ENDPROTECT»
«ENDDEFINE»

«DEFINE nodeMethodFooter FOR uml::ActivityNode»
		return result
	}
«ENDDEFINE»

«DEFINE nodeMethodInput FOR uml::DataStoreNode»
	«this.getGrailsTypeName()» «this.asVariableName()» = arguments.«this.asVariableName()»
«ENDDEFINE»


«DEFINE nodeMethod FOR Ouranos::ProductionRuleset»
	protected «this.asContextName()» «this.asMethodName()»(arguments) {
		«this.asContextName()» result = new «this.asContextName()»()
		com.eenergy.jrules.JRulesService jrs = com.eenergy.jrules.JRulesService.getInstance();
		«PROTECT CSTART "/*" CEND "*/" ID this.fullQualifiedName() + "RulesetFilename"» 
		def rulesetFileName = 'rules/«this.asFullRuleFilePath()»'
		«ENDPROTECT»
		
		// set input
		«this.asContextName()» context = new «this.asContextName()» (
			«FOREACH this.getFirstNodes().getInputChiObjects() AS currSource SEPARATOR ", "»
				«currSource.asVariableName()»: «currSource.asVariableName()-»
			«ENDFOREACH»
			«PROTECT CSTART "/*" CEND "*/" ID this.fullQualifiedName() + "RulesetVariables"»
			/* Put additional variables here */
			«ENDPROTECT» 
		)

		def unNamedParameters = []
		def namedInParameters = [:]
		«PROTECT CSTART "/*" CEND "*/" ID this.fullQualifiedName() + "AdditionalParameters"» 
		/* Add named and unnamed parameters here
		 * e.g.
		 * unNamedParameters.add(arguments.myValue)
		 * namedInParameters.myParameter = arguments.myValue
		 */
		«ENDPROTECT»
		unNamedParameters.add(context)
				
		// execute ruleset
		def executeResult = ''
		while (context.rulesetState != «this.asContextName()».RulesetState.END) {
			executeResult = jrs.execute(rulesetFileName, unNamedParameters, namedInParameters)
			if (executeResult.'ilog.rules.firedRulesCount' == 0) {
				context.rulesetState = «this.asContextName()».RulesetState.END;
			}
			switch (context.rulesetState) {
				«PROTECT CSTART "/*" CEND "*/" ID this.fullQualifiedName() + "RulesetSwitch"» 
				/* Put code for additional states here */
				case «this.asContextName()».RulesetState.END:
					/* Put code for setting the result here */
					result.selection = context.selection
					break
				«ENDPROTECT»
			}
		}
		return result
	}
«ENDDEFINE»
