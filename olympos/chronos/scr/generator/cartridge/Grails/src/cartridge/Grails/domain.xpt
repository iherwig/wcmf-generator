«IMPORT uml»
«IMPORT Chronos»


«EXTENSION common::util»
«EXTENSION common::umlutils»
«EXTENSION common::nameNormalizer»
«EXTENSION common::cim»

«EXTENSION cartridge::ChronosCommon::domain::ChiNode»
«EXTENSION cartridge::ChiCmf::extensions::util»
«EXTENSION cartridge::Grails::classtools»

«DEFINE root FOR uml::Model»
	«EXPAND domainClass FOREACH this.allOwnedElements().typeSelect(ChiNode).select(e|!e.isManyToMany() && !e.isLibraryClass()).removeCommonClasses()»
	«EXPAND domainEnum FOREACH this.allOwnedElements().typeSelect(uml::Enumeration)»
«ENDDEFINE»

«REM»For the time being, all package references are commented.«ENDREM»

«REM» Main domain root «ENDREM»
«DEFINE domainClass FOR ChiNode»
	«info("Generating " + this.name)»
	«REM»
	«LET this.getNearestPackage().getPackageName() AS fullQualifiedPackage»
	«FILE (!fullQualifiedPackage.isNullOrEmpty() ? fullQualifiedPackage.asPath() + "/" : "") + this.name +".groovy"-»
	«ENDREM»
	«FILE this.name +".groovy"-»
«groovyFileHeader()»

/* «generatorSignature()» */

«REM»
«IF !fullQualifiedPackage.isNullOrEmpty()-»
package «fullQualifiedPackage»
«ENDIF-»

	«EXPAND Import FOR this-»
«ENDREM»
package com.eenergy.meregio.domain

import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlType;
import javax.xml.bind.annotation.XmlTransient;

«PROTECT CSTART "/*" CEND "*/" ID this.fullQualifiedName() + "Imports"» 
/* put additional imports here */
«ENDPROTECT»

/**
 * «this.getComment("\n * ")»
 */
@XmlAccessorType(XmlAccessType.FIELD)
«REM» avoiding abstract bug in Grails«IF this.isAbstract»abstract «ENDIF-»«ENDREM-»
class «name-» 
«IF !this.superClass.select(e|!e.isLibraryClass()).isEmpty» extends «this.superClass.first().name»«ENDIF»
{
	«REM» Attributes «ENDREM-»
«EXPAND Attribute FOREACH this.getOwnChiAttributes()-»

	«PROTECT CSTART "/*" CEND "*/" ID this.fullQualifiedName() + "Attributes"» 
	/* put additional attributes here */
	«ENDPROTECT»

	«REM» Every property where e reference for navigation is stored «ENDREM-»
«EXPAND ReferenceProperties FOR this-»

	«REM» many-to-one parents (1:1 relations are handled as ReferenceProperty)«ENDREM-»
«EXPAND ManyToOneParents FOR this-»

«EXPAND ToManyChildren FOR this-»					

	«REM» MappedBy for handling multiple relations between the same Classes «ENDREM-»
«EXPAND MappedBy FOR this-»
					
	«REM» Mapping «ENDREM-»
«EXPAND Mapping FOR this-»

	«REM» Constraints «ENDREM-»
«EXPAND Constraints FOR this-»

	«REM» Methods «ENDREM-»
«EXPAND Method(this) FOREACH ownedOperation-»

	«PROTECT CSTART "/*" CEND "*/" ID this.fullQualifiedName() + "Methods"» 
	/* put additional methods here */
	«ENDPROTECT»
}
	«ENDFILE»
	«REM»«ENDLET»«ENDREM»
«ENDDEFINE»	

«DEFINE Import FOR Chronos::ChiNode-»
	«FOREACH this.getImportedClasses() AS import-»
import «IF !import.getNearestPackage().getPackageName().isNullOrEmpty()»«import.getNearestPackage().getPackageName()».«ENDIF-»
«import.name»;
	«ENDFOREACH-»
«ENDDEFINE»

«DEFINE MappedBy FOR ChiNode-»
«LET ((List[uml::Property]) {}
	.addAll(this.getNavigableParentNodes())
	.addAll(this.getNavigableChildNodes())
	.addAll(((List[Chronos::ChiNode]) this.getSuperClassesRecursive()).getNavigableParentNodes())
	.addAll(((List[Chronos::ChiNode]) this.getSuperClassesRecursive()).getNavigableChildNodes())
	).select(e|e.isNavigable() && e.getOtherEnd().isNavigable())
	AS relatives-»
«IF relatives.size > 0-»
	static mappedBy = [
«FOREACH relatives AS relative SEPARATOR ","»
		«relative.getRoleName().toFirstLower().sanitizeType()»«this.getHierarchyRole(relative)»: "«relative.getOtherEnd().getRoleName().toFirstLower().sanitizeType()»"«""-»
«ENDFOREACH»

		«PROTECT CSTART "/*" CEND "*/" ID this.fullQualifiedName() + "MappedBy"» 
		/* put additional mappings here */
		«ENDPROTECT»
	]
«ENDIF-»
«ENDLET-»
«ENDDEFINE»

«DEFINE Mapping FOR ChiNode-»
	static mapping = {
		tablePerHierarchy false
		tablePerSubclass true
«LET this.getNavigableChildNodes().select(e|!e.association.isOneToOneAssociation()) AS children-»
«LET this.getNavigableParentNodes().select(e|e.isMultivalued() && e.getOtherEnd().isMultivalued()) AS parents-»
«LET ((List[uml::Property]) {}.addAll(children).addAll(parents)) AS relatives-»
«FOREACH relatives AS relative»
«LET relative.getRoleName().toFirstLower() AS name-»
«IF relative.aggregation == AggregationKind::shared-»
			«name» cascade: "persist,save-update"
«ELSE-»
			«name» cascade: "none"
«ENDIF-»
«ENDLET-»
«ENDFOREACH»
«ENDLET-»
«ENDLET-»
«ENDLET-»

		«PROTECT CSTART "/*" CEND "*/" ID this.fullQualifiedName() + "Mappings"» 
		/* put additional mappings here */
		«ENDPROTECT»
	}
«ENDDEFINE»	

«REM» simple reference «ENDREM»
«DEFINE ReferenceProperties FOR ChiNode-»
«LET {}
	.addAll(this.getNavigableParentNodes())
	.addAll(this.getNavigableChildNodes())
	.select(e|((uml::Property) e).association.isOneToOneAssociation()) AS others-»
«IF others.size > 0»
«FOREACH others AS other-»
	/**
	 * «((uml::Property) other).getComment("\n	 * ")»
	 */
	@XmlElement
	«((uml::Property) other).type.name.sanitizeType()» «((uml::Property) other).getRoleName().toFirstLower().sanitizeType()»
«ENDFOREACH-»
«ENDIF-»
«ENDLET-»
«ENDDEFINE»

«REM» many-to-one parents (1:1 relations are handled as ReferenceProperty)«ENDREM»
«DEFINE ManyToOneParents FOR ChiNode-»
«LET ((List[uml::Property]) {}
		.addAll(this.getNavigableParentNodes()) //.select(e|!e.association.isOneToOneAssociation()))
		.addAll(this.getNavigableChildNodes().select(e|
			{}.addAll(((Chronos::ChiNode) e.type).getSuperClassesRecursive()).add(e.type).contains(this.getFirstManyToManyChild((Chronos::ChiNode) e.type))
		))
	)
	AS parents -»
«LET ((List[Chronos::ChiNode]) {}
		.addAll(this.getModel().allOwnedElements().typeSelect(Chronos::ChiValue).select(e|e.type == this).class.toSet())
	)
	AS owners -»
«parents.size > 0 && owners.size > 0 ? (
	warn("Both parents and owners exist for " + this.name) ->
	""
) : (
	""
)-»
«IF parents.size > 0-»
	«FOREACH parents.select(e|e.upperBound() == 1 || e.getOtherEnd().upperBound() == 1) AS parent»
	@XmlTransient
	«parent.type.name.sanitizeType()» «parent.getRoleName().toFirstLower()»
	«ENDFOREACH»
	
	«PROTECT CSTART "/*" CEND "*/" ID this.fullQualifiedName() + "belongsToLists"» 
	/* put additional lists here */
	«ENDPROTECT»

	static belongsTo = [
	«FOREACH parents AS parent SEPARATOR ","»
		«parent.getRoleName().toFirstLower()»: «parent.type.name.sanitizeType()-»
	«ENDFOREACH»
	
		«PROTECT CSTART "/*" CEND "*/" ID this.fullQualifiedName() + "belongsToParents"» 
		/* put additional belongsTo here */
		«ENDPROTECT»
	]
«ELSEIF owners.size > 0-»
	static belongsTo = [
	«FOREACH owners AS owner SEPARATOR ","»
		«owner.name.sanitizeType()-»
	«ENDFOREACH»
	
		«PROTECT CSTART "/*" CEND "*/" ID this.fullQualifiedName() + "belongsToOwners"» 
		/* put additional owners here */
		«ENDPROTECT»
	]
«ENDIF-»
«ENDLET-»
«ENDLET-»
«ENDDEFINE»

«REM» one-to-many children (1:1 relations are handled as ReferenceProperty)«ENDREM»
«DEFINE ToManyChildren FOR ChiNode-»
«LET this.getNavigableChildNodes().select(e|!e.association.isOneToOneAssociation()) AS children-»
«LET this.getNavigableParentNodes().select(e|e.isMultivalued() && e.getOtherEnd().isMultivalued()) AS parents-»
«LET ((List[uml::Property]) {}.addAll(children).addAll(parents)) AS relatives-»
«IF relatives.size > 0»
«FOREACH children AS child-»
	@XmlElement
	Set<«child.type.name.sanitizeType()»> «child.getRoleName().toFirstLower()»
«ENDFOREACH-»

«FOREACH parents AS parent-»
	@XmlTransient
	Set<«parent.type.name.sanitizeType()»> «parent.getRoleName().toFirstLower()»
«ENDFOREACH»

	static hasMany = [
«FOREACH relatives AS relative SEPARATOR ","»
		«relative.getRoleName().toFirstLower()»: «relative.type.name.sanitizeType()-»
«ENDFOREACH»

		«PROTECT CSTART "/*" CEND "*/" ID this.fullQualifiedName() + "hasMany"» 
		/* put additional hasMany here */
		«ENDPROTECT»
	]
«ENDIF-»
«ENDLET-»
«ENDLET-»
«ENDLET-»
«ENDDEFINE»

«REM» fill constraints for attributes  «ENDREM»
«DEFINE Constraints FOR ChiNode-»
«LET ((List[uml::Property]) {}
	.addAll(this.getNavigableParentNodes())
	.addAll(this.getNavigableChildNodes())
	.addAll(this.getOwnChiAttributes()))
 AS constraintAttributes-»
«IF constraintAttributes.size > 0-»
	static constraints = {
	«FOREACH constraintAttributes AS c-»
		«LET {
			c.hasRestrictionsMatch() ? "matches: \"" + c.getTaggedValue("Chronos::ChiValue", "restrictions_match") + "\"" : null,
			c.isNullable()? "nullable: true" : "nullable: true" /*TODO: temporary reset, second one should be false*/,
			c.association != null && c.lowerBound() > 0 ? "minSize: " + c.lowerBound() : null,
			c.association != null && c.upperBound() >= 0 ? "maxSize: " + c.upperBound() : null
		}.select(e|e != null)
		AS constraints»
			«c.getPropertyName()»(
				«FOREACH constraints AS constraint SEPARATOR ", "»«constraint»«ENDFOREACH»
			)
		«ENDLET-»
	«ENDFOREACH-»

		«PROTECT CSTART "/*" CEND "*/" ID this.fullQualifiedName() + "constraints"» 
		/* put additional constraints here */
		«ENDPROTECT»
	}
«ENDIF-»
«ENDLET-»
«ENDDEFINE»

«REM» simply attribute «ENDREM»
«DEFINE Attribute FOR ChiValue-»
	/**
	 * «this.getComment("\n	 * ")»
	 */
	@XmlElement«IF this.lowerBound() > 0»(required = true)«ENDIF»
	«this.type.name.sanitizeType()»«IF this.isMultivalued()»[]«ENDIF» «name»«IF !this.^default.isNullOrEmpty()» = «this.type.getValuePrefix()»«this.^default»«this.type.getValuePostfix()»«ENDIF»
	
«ENDDEFINE»

«REM» simple method wiequired=true)
th protected region «ENDREM»
«DEFINE Method(Class clazz) FOR Operation-»
	/**
	 * «this.getComment("\n	 * ")»
	 */
	«this.returnResult().first().type.name.sanitizeType()» «name»() {
		// Here you are able to implement your own code
		«PROTECT CSTART '/*' CEND '*/' ID this.getId()»
					
		«ENDPROTECT»
	} 
«ENDDEFINE»

«DEFINE domainEnum FOR uml::Enumeration»
«info("Generating enumeration " + this.name)»
	«FILE this.name +".groovy"-»
«groovyFileHeader()»

/* «generatorSignature()» */

package com.eenergy.meregio.domain

import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlType;
import javax.xml.bind.annotation.XmlTransient;

«PROTECT CSTART "/*" CEND "*/" ID this.fullQualifiedName() + "Imports"» 
/* put additional imports here */
«ENDPROTECT»

/**
 * «this.getComment("\n * ")»
 */
@XmlAccessorType(XmlAccessType.FIELD)
enum «name-» {
	«FOREACH this.ownedLiteral.select(e|e == this.ownedLiteral.select(f|f.name.normalizeMemberName() == e.name.normalizeMemberName()).first()) AS currLiteral SEPARATOR ",\n\t"»«currLiteral.name.normalizeMemberName()»«ENDFOREACH»

	«PROTECT CSTART "/*" CEND "*/" ID this.fullQualifiedName() + "Body"» 
	/* put additional attributes and methods here */
	«ENDPROTECT»
}
	«ENDFILE»
«ENDDEFINE»