«IMPORT uml»
«IMPORT Chronos»


«EXTENSION common::util»
«EXTENSION common::umlutils»
«EXTENSION common::nameNormalizer»
«EXTENSION common::cim»

«EXTENSION cartridge::ChronosCommon::domain::ChiNode»
«EXTENSION cartridge::ChiCmf::extensions::util»
«EXTENSION cartridge::Grails::classtools»

«DEFINE root FOR uml::Model»
	«EXPAND domainClass FOREACH this.allOwnedElements().typeSelect(ChiNode).select(e|!e.isManyToMany() && !e.isLibraryClass()).removeCommonClasses()»
	«EXPAND domainEnum FOREACH this.allOwnedElements().typeSelect(uml::Enumeration)»
«ENDDEFINE»

«REM»For the time being, all package references are commented.«ENDREM»

«REM» Main domain root «ENDREM»
«DEFINE domainClass FOR ChiNode»
	«info("Generating " + this.name)»
	«REM»
	«LET this.getNearestPackage().getPackageName() AS fullQualifiedPackage»
	«FILE (!fullQualifiedPackage.isNullOrEmpty() ? fullQualifiedPackage.asPath() + "/" : "") + this.name +".groovy"-»
	«ENDREM»
	«FILE this.name +".groovy"-»
«groovyFileHeader()»

/* «generatorSignature()» */

«REM»
«IF !fullQualifiedPackage.isNullOrEmpty()-»
package «fullQualifiedPackage»
«ENDIF-»

	«EXPAND imports FOR this-»
«ENDREM»
package com.eenergy.meregio.domain

import javax.xml.bind.annotation.XmlAccessorType
import javax.xml.bind.annotation.XmlAccessType
import javax.xml.bind.annotation.XmlElement
import javax.xml.bind.annotation.XmlType
import javax.xml.bind.annotation.XmlTransient
import javax.xml.bind.annotation.XmlID
import javax.xml.bind.annotation.XmlIDREF

«PROTECT CSTART "/*" CEND "*/" ID this.fullQualifiedName() + "Imports"» 
/* put additional imports here */
«ENDPROTECT»

/**
 * «this.getComment("\n * ")»
 */
@XmlAccessorType(XmlAccessType.NONE)
«REM» avoiding abstract bug in Grails«IF this.isAbstract»abstract «ENDIF-»«ENDREM»
class «name-» 
«IF !this.superClass.select(e|!e.isLibraryClass()).isEmpty» extends «this.superClass.first().name»«ENDIF»
{
«EXPAND attributes FOR this-»

«EXPAND complexAttributes FOR this-»

«EXPAND associations FOR this-»

«EXPAND belongsTo FOR this-»

«EXPAND hasMany FOR this-»

«EXPAND mappedBy FOR this-»
					
«EXPAND mapping FOR this-»

«EXPAND constraints FOR this-»

«EXPAND methods FOR this-»

}
	«ENDFILE»
	«REM»«ENDLET»«ENDREM»
«ENDDEFINE»	

«DEFINE imports FOR Chronos::ChiNode-»
	«FOREACH this.getImportedClasses() AS currImport-»
import «IF !currImport.getNearestPackage().getPackageName().isNullOrEmpty()»«currImport.getNearestPackage().getPackageName()».«ENDIF-»
«currImport.name»;
	«ENDFOREACH-»
«ENDDEFINE»

«DEFINE attributes FOR Chronos::ChiNode-»
	«FOREACH this.getOwnChiAttributes() AS currAttribute-»
	/**
	 * «currAttribute.getComment("\n	 * ")»
	 */
	@XmlElement«IF currAttribute.lowerBound() > 0»(required = true)«ENDIF»
	«IF currAttribute.name == "mRID"»@XmlID«ENDIF»
	«currAttribute.type.name.sanitizeType()»«IF currAttribute.isMultivalued()»[]«ENDIF» «currAttribute.name»«IF !currAttribute.^default.isNullOrEmpty()» = «currAttribute.type.getValuePrefix()»«currAttribute.^default»«currAttribute.type.getValuePostfix()»«ENDIF»
	«ENDFOREACH»	

	«PROTECT CSTART "/*" CEND "*/" ID this.fullQualifiedName() + "Attributes"» 
	/* put additional attributes here */
	«ENDPROTECT»
«ENDDEFINE»

«DEFINE complexAttributes FOR Chronos::ChiNode-»
	«LET (
		(List[uml::Property]) {}
		.addAll(this.attribute.select(e|e.association == null))
		.removeAll(this.getOwnChiAttributes())
	)
	AS attributes-»
	«FOREACH attributes AS currAttribute-»
	/**
	 * «currAttribute.getComment("\n	* ")»
	 */
	@XmlElement«IF currAttribute.lowerBound() > 0»(required = true)«ENDIF»
	«currAttribute.type.name.sanitizeType()»«IF currAttribute.isMultivalued()»[]«ENDIF» «currAttribute.name»
	«ENDFOREACH»
	«ENDLET-»
«ENDDEFINE»

«DEFINE associations FOR Chronos::ChiNode-»
	«LET (
		(List[uml::Property]) {}
		.addAll(this.getOwnAssociationEnds())
	).select(e|e.isNavigable())
	AS associations-»
	«FOREACH associations AS currAssociation-»
	/**
	 * «currAssociation.getComment("\n	* ")»
	 */
	@XmlElement«IF currAssociation.lowerBound() > 0»(required = true)«ENDIF»
	«IF !this.isContainer()»@XmlIDREF«ENDIF»
	«IF currAssociation.isMultivalued()»Set<«currAssociation.type.name.sanitizeType()»>«ELSE»«currAssociation.type.name.sanitizeType()»«ENDIF» «currAssociation.getRoleName().toFirstLower()»
	
	«ENDFOREACH»
	«ENDLET-»
«ENDDEFINE»

«DEFINE hasMany FOR Chronos::ChiNode-»
	«LET (
		(List[uml::Property]) {}
		.addAll(this.getOwnAssociationEnds())
	).select(e|e.isNavigable() && e.isMultivalued())
	AS associations-»
	«IF associations.size > 0»
	static hasMany = [
	«FOREACH associations AS currAssociation SEPARATOR ", "»
		«currAssociation.getRoleName().toFirstLower()»: «currAssociation.type.name.sanitizeType()-» 
	«ENDFOREACH»

		«PROTECT CSTART "/*" CEND "*/" ID this.fullQualifiedName() + "hasMany"» 
		/* put additional hasMany here */
		«ENDPROTECT»
	]
	«ENDIF»

	«ENDLET-»
«ENDDEFINE»

«DEFINE belongsTo FOR Chronos::ChiNode-»
	«LET ((List[uml::Property]) {}
		.addAll(this.getNavigableParentNodes())
		.addAll(this.getOwnAssociationEnds().select(e|
			{}
				.addAll(((Chronos::ChiNode) e.type).getSuperClassesRecursive())
				.add(e.type)
			.contains(this.getFirstManyToManyChild((Chronos::ChiNode) e.type))
			|| e.aggregation != uml::AggregationKind::none
		))
	)
	AS parents -»
	«LET ((List[Chronos::ChiNode]) {}
		.addAll(this.getModel().allOwnedElements().typeSelect(Chronos::ChiValue).select(e|e.type == this).class.toSet())
	)
	AS owners -»
	«parents.size > 0 && owners.size > 0 ? (
		warn("Both parents and owners exist for " + this.name) ->
		""
	) : (
		""
	)-»
	«IF parents.size > 0 || owners.size > 0»
	static belongsTo = [
	«IF parents.size > 0-»
		«FOREACH parents AS parent SEPARATOR ","»
		«parent.getRoleName().toFirstLower()»: «parent.type.name.sanitizeType()-»
		«ENDFOREACH»
	«ELSEIF owners.size > 0-»
		«FOREACH owners AS owner SEPARATOR ","»
		«owner.name.sanitizeType()-»
		«ENDFOREACH»
	«ENDIF-»
	
		«PROTECT CSTART "/*" CEND "*/" ID this.fullQualifiedName() + "belongsTo"» 
		/* put additional belongsTo here */
		«ENDPROTECT»
	]
	«ENDIF»
	«ENDLET-»
	«ENDLET-»
«ENDDEFINE»»		
	
«DEFINE mappedBy FOR ChiNode-»
	«LET (
		(List[uml::Property]) {}
		.addAll(this.getOwnAssociationEnds())
		).select(e|e.isNavigable() && e.getOtherEnd().isNavigable())
	AS relatives-»
	«IF relatives.size > 0-»
	static mappedBy = [
		«FOREACH relatives AS relative SEPARATOR ","»
		«relative.getRoleName().toFirstLower()»«this.getHierarchyRole(relative)»: "«relative.getOtherEnd().getRoleName().toFirstLower()»"«""-»
		«ENDFOREACH»

		«PROTECT CSTART "/*" CEND "*/" ID this.fullQualifiedName() + "MappedBy"» 
		/* put additional mappings here */
		«ENDPROTECT»
	]
	«ENDIF-»
	«ENDLET-»
«ENDDEFINE»

«DEFINE mapping FOR Chronos::ChiNode-»
	static mapping = {
		tablePerHierarchy false
		tablePerSubclass true
	«LET this.getNavigableChildNodes().select(e|!e.association.isOneToOneAssociation()) AS children-»
		«LET this.getNavigableParentNodes().select(e|e.isMultivalued() && e.getOtherEnd().isMultivalued()) AS parents-»
			«LET ((List[uml::Property]) {}.addAll(children).addAll(parents)) AS relatives-»
				«FOREACH relatives AS relative»
					«LET relative.getRoleName().toFirstLower() AS name-»
						«IF relative.aggregation == AggregationKind::shared-»
			«name» cascade: "persist,save-update"
						«ELSE-»
			«name» cascade: "none"
						«ENDIF-»
					«ENDLET-»
				«ENDFOREACH»
			«ENDLET-»
		«ENDLET-»
	«ENDLET-»

	«PROTECT CSTART "/*" CEND "*/" ID this.fullQualifiedName() + "Mappings"» 
		/* put additional mappings here */
	«ENDPROTECT»
	}
«ENDDEFINE»	

«DEFINE constraints FOR Chronos::ChiNode-»
	«LET (
		(List[uml::Property]) {}
		.addAll(this.getNavigableParentNodes())
		.addAll(this.getNavigableChildNodes())
		.addAll(this.getOwnChiAttributes())
		.addAll(this.attribute)
	).toSet().toList()
	AS constraintAttributes-»
	«IF constraintAttributes.size > 0-»
	static constraints = {
		«FOREACH constraintAttributes AS c-»
			«LET {
				c.hasRestrictionsMatch() ? "matches: \"" + c.getTaggedValue("Chronos::ChiValue", "restrictions_match") + "\"" : null,
				c.isNullable()? "nullable: true" : "nullable: true" /*TODO: temporary reset, second one should be false*/,
				c.association != null && c.lowerBound() > 0 ? "minSize: " + c.lowerBound() : null,
				c.association != null && c.upperBound() >= 0 ? "maxSize: " + c.upperBound() : null
			}.select(e|e != null)
			AS constraints»
			«c.getPropertyName()»(
				«FOREACH constraints AS constraint SEPARATOR ", "»«constraint»«ENDFOREACH»
			)
			«ENDLET-»
		«ENDFOREACH-»

		«PROTECT CSTART "/*" CEND "*/" ID this.fullQualifiedName() + "constraints"» 
		/* put additional constraints here */
		«ENDPROTECT»
	}
	«ENDIF-»
	«ENDLET-»
«ENDDEFINE»

«DEFINE methods FOR Chronos::ChiNode-»
	«FOREACH this.getOperations() AS currOperation-»
	/**
	 * «currOperation.getComment("\n	 * ")»
	 */
	«currOperation.returnResult().first().type.name.sanitizeType()» «currOperation.name»() {
		// Here you are able to implement your own code
		«PROTECT CSTART '/*' CEND '*/' ID this.getId()»
					
		«ENDPROTECT»
	}
	«ENDFOREACH» 

	«PROTECT CSTART "/*" CEND "*/" ID this.fullQualifiedName() + "Methods"» 
	/* put additional methods here */
	«ENDPROTECT»
«ENDDEFINE»

«DEFINE domainEnum FOR uml::Enumeration»
«info("Generating enumeration " + this.name)»
	«FILE this.name +".groovy"-»
«groovyFileHeader()»

/* «generatorSignature()» */

package com.eenergy.meregio.domain

import javax.xml.bind.annotation.XmlAccessorType
import javax.xml.bind.annotation.XmlAccessType
import javax.xml.bind.annotation.XmlElement
import javax.xml.bind.annotation.XmlType
import javax.xml.bind.annotation.XmlTransient
import javax.xml.bind.annotation.XmlID
import javax.xml.bind.annotation.XmlIDREF

«PROTECT CSTART "/*" CEND "*/" ID this.fullQualifiedName() + "Imports"» 
/* put additional imports here */
«ENDPROTECT»

/**
 * «this.getComment("\n * ")»
 */
@XmlAccessorType(XmlAccessType.FIELD)
enum «name-» {
	«FOREACH this.ownedLiteral.select(e|e == this.ownedLiteral.select(f|f.name.normalizeMemberName() == e.name.normalizeMemberName()).first()) AS currLiteral SEPARATOR ",\n\t"»«currLiteral.name.normalizeMemberName()»«ENDFOREACH»

	«PROTECT CSTART "/*" CEND "*/" ID this.fullQualifiedName() + "Body"» 
	/* put additional attributes and methods here */
	«ENDPROTECT»
}
	«ENDFILE»
«ENDDEFINE»
