<!doctype html public "-//W3C//DTD HTML 4.0 Frameset//EN""http://www.w3.org/TR/REC-html40/frameset.dtd">
<html>
<head>
<title>
Chronos Web Modeler Overview
</title>
<link rel ="stylesheet" type="text/css" href="stylesheet.css" title="Style">
<script>
function asd() {
	
		parent.document.title="autolayout.js Overview";
	
}
</script>
</head>
<body bgcolor="white" onload="asd();">

<!-- ========== START OF NAVBAR ========== -->
<a name="navbar_top"><!-- --></a>
<table border="0" width="100%" cellpadding="1" cellspacing="0">
<tr>
<td colspan=2 bgcolor="#EEEEFF" class="NavBarCell1">
<a name="navbar_top_firstrow"><!-- --></a>
<table border="0" cellpadding="0" cellspacing="3">
  <tr align="center" valign="top">
  
  
  <td bgcolor="#EEEEFF" class="NavBarCell1">    <a href="overview-summary.html"><font class="NavBarFont1"><b>Overview</b></font></a>&nbsp;</td>
  <td bgcolor="#FFFFFF" class="NavBarCell1Rev">	&nbsp;<font class="NavBarFont1Rev"><b>File</b></font>&nbsp;</td>
  

  <td bgcolor="#FFFFFF" class="NavBarCell1"> 	<font class="NavBarFont1">Class</font>&nbsp;</td>
  <td bgcolor="#EEEEFF" class="NavBarCell1">    <a href="overview-tree.html"><font class="NavBarFont1"><b>Tree</b></font></a>&nbsp;</td>
  <td bgcolor="#EEEEFF" class="NavBarCell1">    <a href="index-all.html"--><font class="NavBarFont1"><b>Index</b></font></a>&nbsp;</td>
  <td bgcolor="#EEEEFF" class="NavBarCell1">    <a href="help-doc.html"><font class="NavBarFont1"><b>Help</b></font></a>&nbsp;</td>
  </tr>
</table>
</td>
<td bgcolor="#EEEEFF" align="right" valign="top">
<em>
<b>Chronos Web Modeler</b></em>
</td>
</tr>

<tr>
<td bgcolor="white" class="NavBarCell2"><font size="-2">
&nbsp;PREV&nbsp;
&nbsp;NEXT</font></td>
<td bgcolor="white" class="NavBarCell2"><font size="-2">
  <a href="index.html" target="_top"><b>FRAMES</b></a>  &nbsp;
&nbsp;<a href="overview-summary.html" target="_top"><b>NO FRAMES</b></a>
&nbsp;&nbsp;
<script>
  <!--
  if(window==top) {
    document.writeln('<A HREF="allclasses-noframe.html" TARGET=""><B>All Classes</B></A>');
  }
  //-->
</script>
<noscript>
<a href="allclasses-noframe.html" target=""><b>All Classes</b></a>
</noscript>
</font></td>
</tr>
</table>
<!-- =========== END OF NAVBAR =========== -->

<hr>
<center>
	
	   <h2>autolayout.js</h2>
	
</center>

	


<h4>Summary</h4>
<p>
	
		No overview generated for 'autolayout.js'<BR/><BR/>
	
</p>

<hr>



<!-- ========== METHOD SUMMARY =========== -->

<!-- ========== END METHOD SUMMARY =========== -->


        <pre class="sourceview">Ext.namespace(<span class="literal">"uwm.diagram.autolayout"</span>);

<span class="comment">///JiggleObject</span>

uwm.diagram.autolayout.JiggleObject = <span class="reserved">function</span>() {
	<span class="reserved">this</span>.booleanField = false;
	<span class="reserved">this</span>.intField = 0;
	<span class="reserved">this</span>.objectField = null;
	<span class="comment">/* The context of a JiggleObject identifies the parent JiggleObject
	 (if any) that contains it.  The context of a Vertex or Cell is either
	 a Graph or a Cell; the context of an Edge is a Graph; the context of
	 an EdgeLabel is an Edge.  For now, we assume that the	context of a
	 Graph is null; if, however, we extend the present implementation to
	 include composite graphs, then the context of a Graph	could be a
	 JiggleObject (e.g. a Vertex) that contains the graph inside	it. */</span>
	<span class="reserved">this</span>.context = null;
}

uwm.diagram.autolayout.JiggleObject.<span class="reserved">prototype</span>.getContext = <span class="reserved">function</span>() {
	<span class="reserved">return</span> <span class="reserved">this</span>.context;
}

uwm.diagram.autolayout.JiggleObject.<span class="reserved">prototype</span>.setContext = <span class="reserved">function</span>(c) {
	<span class="reserved">this</span>.context = c;
}

uwm.diagram.autolayout.JiggleObject.<span class="reserved">prototype</span>.square = <span class="reserved">function</span>(d) {
	<span class="reserved">return</span> d * d;
}

uwm.diagram.autolayout.JiggleObject.<span class="reserved">prototype</span>.cube = <span class="reserved">function</span>(d) {
	<span class="reserved">return</span> d * d * d;
}

uwm.diagram.autolayout.JiggleObject.<span class="reserved">prototype</span>.intSquare = <span class="reserved">function</span>(n) {
	<span class="reserved">return</span> n * n;
}

uwm.diagram.autolayout.JiggleObject.<span class="reserved">prototype</span>.power = <span class="reserved">function</span>(base, d) {
	<span class="reserved">if</span> (d == 0) 
		<span class="reserved">return</span> 1;
	<span class="reserved">else</span> <span class="reserved">if</span> (d == 1) 
		<span class="reserved">return</span> base;
	<span class="reserved">else</span> <span class="reserved">if</span> (d % 2 == 0) 
		<span class="reserved">return</span> <span class="reserved">this</span>.intSquare(<span class="reserved">this</span>.power(base, d / 2));
	<span class="reserved">else</span> 
		<span class="reserved">return</span> base * <span class="reserved">this</span>.intSquare(<span class="reserved">this</span>.power(base, d / 2));
}

<span class="comment">///ForceLaw</span>

uwm.diagram.autolayout.ForceLaw = <span class="reserved">function</span>(graph) {
	uwm.diagram.autolayout.JiggleObject.call(<span class="reserved">this</span>);
	
	<span class="reserved">this</span>.graph = graph;
	<span class="reserved">this</span>.cap = Number.MAX_VALUE / 1000
}

uwm.diagram.autolayout.ForceLaw.<span class="reserved">prototype</span> = new uwm.diagram.autolayout.JiggleObject;


uwm.diagram.autolayout.ForceLaw.<span class="reserved">prototype</span>.getCap = <span class="reserved">function</span>() {
	<span class="reserved">return</span> <span class="reserved">this</span>.cap;
}

uwm.diagram.autolayout.ForceLaw.<span class="reserved">prototype</span>.setCap = <span class="reserved">function</span>(cap) {
	<span class="reserved">this</span>.cap = cap;
}

<span class="comment">///SpringLaw</span>

uwm.diagram.autolayout.SpringLaw = <span class="reserved">function</span>(graph, preferredEdgeLength) {
	uwm.diagram.autolayout.ForceLaw.call(<span class="reserved">this</span>, graph);
	<span class="reserved">this</span>.preferredEdgeLength = preferredEdgeLength;
}

uwm.diagram.autolayout.SpringLaw.<span class="reserved">prototype</span> = new uwm.diagram.autolayout.ForceLaw;

uwm.diagram.autolayout.SpringLaw.<span class="reserved">prototype</span>.apply = <span class="reserved">function</span>(negativeGradient) {
	var m = <span class="reserved">this</span>.graph.numberOfEdges;
	var d = <span class="reserved">this</span>.graph.getDimensions();
	<span class="reserved">for</span> (var i = 0; i &lt; m; i++) {
		var e = <span class="reserved">this</span>.graph.edges.get(i);
		var from = e.getFrom();
		var to = e.getTo();
		var fromWeight = from.getWeight();
		var toWeight = to.getWeight();
		var f = from.intField;
		var t = to.intField;
		var w = Math.min(<span class="reserved">this</span>.springAttraction(e), <span class="reserved">this</span>.cap / e.getLength());
		var fromCoords = from.getCoords();
		var toCoords = to.getCoords();
		<span class="reserved">for</span> (var j = 0; j &lt; d; j++) {
			var force = (toCoords[j] - fromCoords[j]) * w;
			negativeGradient[f][j] += force * toWeight;
			negativeGradient[t][j] -= force * fromWeight;
		}
	}
}

<span class="comment">///QuadraticSpringLaw</span>

uwm.diagram.autolayout.QuadraticSpringLaw = <span class="reserved">function</span>(graph, preferredEdgeLength) {
	uwm.diagram.autolayout.SpringLaw.call(<span class="reserved">this</span>, graph, preferredEdgeLength);
}

uwm.diagram.autolayout.QuadraticSpringLaw.<span class="reserved">prototype</span> = new uwm.diagram.autolayout.SpringLaw;

uwm.diagram.autolayout.QuadraticSpringLaw.<span class="reserved">prototype</span>.springAttraction = <span class="reserved">function</span>(edge) {
	var r = uwm.diagram.autolayout.Cell.<span class="reserved">prototype</span>.sumOfRadii(edge.getFrom(), edge.getTo());
	var len = edge.getLength();
	<span class="reserved">return</span> (len - r) / <span class="reserved">this</span>.preferredEdgeLength;
}

<span class="comment">///VertexVertexRepulsionLaw</span>

uwm.diagram.autolayout.VertexVertexRepulsionLaw = <span class="reserved">function</span>(graph, preferredEdgeLength) {
	uwm.diagram.autolayout.ForceLaw.call(<span class="reserved">this</span>, graph);
	<span class="reserved">this</span>.preferredEdgeLength = preferredEdgeLength;
	<span class="reserved">this</span>.barnesHutTheta = 0;
}

uwm.diagram.autolayout.VertexVertexRepulsionLaw.<span class="reserved">prototype</span> = new uwm.diagram.autolayout.ForceLaw;

uwm.diagram.autolayout.VertexVertexRepulsionLaw.<span class="reserved">prototype</span>.getBarnesHutTheta = <span class="reserved">function</span>() {
	<span class="reserved">return</span> <span class="reserved">this</span>.barnesHutTheta;
}
uwm.diagram.autolayout.VertexVertexRepulsionLaw.<span class="reserved">prototype</span>.setBarnesHutTheta = <span class="reserved">function</span>(t) {
	<span class="reserved">this</span>.barnesHutTheta = t;
}

uwm.diagram.autolayout.VertexVertexRepulsionLaw.<span class="reserved">prototype</span>.apply = <span class="reserved">function</span>(negativeGradient) {
	<span class="reserved">if</span> (<span class="reserved">this</span>.barnesHutTheta &gt; 0) {
		<span class="reserved">this</span>.applyUsingBarnesHut(negativeGradient);
	}
	var n = <span class="reserved">this</span>.graph.numberOfVertices;
	var d = <span class="reserved">this</span>.graph.getDimensions();
	<span class="reserved">for</span> (var i = 0; i &lt; n - 1; i++) {
		var v1 = <span class="reserved">this</span>.graph.vertices.get(i);
		var v1Coords = v1.getCoords();
		var weight1 = v1.getWeight();
		<span class="reserved">for</span> (var j = i + 1; j &lt; n; j++) {
			var v2 = <span class="reserved">this</span>.graph.vertices.get(j);
			var w = Math.min(<span class="reserved">this</span>.pairwiseRepulsion(v1, v2), <span class="reserved">this</span>.cap / uwm.diagram.autolayout.Vertex.<span class="reserved">prototype</span>.getDistance(v1, v2));
			var v2Coords = v2.getCoords();
			var weight2 = v2.getWeight();
			<span class="reserved">for</span> (var k = 0; k &lt; d; k++) {
				var force = (v1Coords[k] - v2Coords[k]) * w;
				negativeGradient[i][k] += force * weight2;
				negativeGradient[j][k] -= force * weight1;
			}
		}
	}
}

uwm.diagram.autolayout.VertexVertexRepulsionLaw.<span class="reserved">prototype</span>.applyUsingBarnesHut = <span class="reserved">function</span>(negativeGradient) {
	var n = <span class="reserved">this</span>.graph.numberOfVertices;
	var d = <span class="reserved">this</span>.graph.getDimensions();
	<span class="reserved">if</span> (n &lt;= 1) 
		<span class="reserved">return</span>;
	<span class="reserved">this</span>.graph.recomputeBoundaries();
	var root = new uwm.diagram.autolayout.QuadTree(<span class="reserved">this</span>.graph);
	<span class="reserved">for</span> (var i = 0; i &lt; n; i++) {
		var v = <span class="reserved">this</span>.graph.vertices.get(i);
		var qt = v.getContext();
		var cur = qt;
		<span class="reserved">while</span> (cur.getContext() != <span class="reserved">this</span>.graph) {
			var p = cur.getContext();
			var numberOfSubtrees = <span class="reserved">this</span>.power(2, d);
			<span class="reserved">for</span> (var j = 0; j &lt; numberOfSubtrees; j++) {
				var st = p.subtrees[j];
				<span class="reserved">if</span> (cur != st) {
					<span class="reserved">this</span>.computeQTRepulsion(qt, st, negativeGradient);
				}
			}
			cur = p;
		}
	}
	<span class="reserved">this</span>.pushForcesDownTree(root);
	<span class="reserved">for</span> (var i = 0; i &lt; n; i++) {
		var v = <span class="reserved">this</span>.graph.vertices.get(i);
		var qt = v.getContext();
		<span class="reserved">for</span> (var j = 0; j &lt; d; j++) {
			negativeGradient[i][j] += qt.force[j];
		}
		v.setContext(<span class="reserved">this</span>.graph);
	}
}

uwm.diagram.autolayout.VertexVertexRepulsionLaw.<span class="reserved">prototype</span>.computeQTRepulsion = <span class="reserved">function</span>(leaf, cell, negativeGradient) {
	<span class="reserved">if</span> (cell == null) 
		<span class="reserved">return</span>;
	var d = leaf.getDimensions();
	<span class="reserved">if</span> ((cell.objectField == null) &amp;&amp; (!<span class="reserved">this</span>.wellSeparated(leaf, cell))) {
		var numberOfSubtrees = <span class="reserved">this</span>.power(2, d);
		<span class="reserved">for</span> (var i = 0; i &lt; numberOfSubtrees; i++) {
			<span class="reserved">this</span>.computeQTRepulsion(leaf, cell.subtrees[i], negativeGradient);
		}
	}
	<span class="reserved">else</span> {
		var w = Math.min(<span class="reserved">this</span>.pairwiseRepulsion(leaf, cell), <span class="reserved">this</span>.cap / uwm.diagram.autolayout.Cell.<span class="reserved">prototype</span>.getDistance(leaf, cell));
		var leafWeight = leaf.getWeight();
		var cellWeight = cell.getWeight();
		var leafCoords = leaf.getCoords();
		var cellCoords = cell.getCoords();
		var i = leaf.intField;
		<span class="reserved">for</span> (var j = 0; j &lt; d; j++) {
			var force = 0.5 * w * (leafCoords[j] - cellCoords[j]);
			negativeGradient[i][j] += force * cellWeight;
			cell.force[j] -= force * leafWeight;
		}
	}
}

uwm.diagram.autolayout.VertexVertexRepulsionLaw.<span class="reserved">prototype</span>.wellSeparated = <span class="reserved">function</span>(leaf, cell) {
	<span class="reserved">if</span> (cell == null) 
		throw new Error(<span class="literal">"cell == null"</span>);
	<span class="reserved">if</span> (cell.objectField != null) 
		<span class="reserved">return</span> true;
	<span class="reserved">else</span> {
		var d = cell.getDimensions();
		var len = Number.MAX_VALUE;
		var lo = cell.getMin();
		var hi = cell.getMax();
		<span class="reserved">for</span> (var i = 0; i &lt; d; i++) {
			len = Math.min(len, hi[i] - lo[i]);
		}
		var dist = uwm.diagram.autolayout.Cell.<span class="reserved">prototype</span>.getDistance(leaf, cell);
		<span class="reserved">return</span> ((len / dist) &lt; <span class="reserved">this</span>.barnesHutTheta);
	}
}

uwm.diagram.autolayout.VertexVertexRepulsionLaw.<span class="reserved">prototype</span>.pushForcesDownTree = <span class="reserved">function</span>(qt) {
	<span class="reserved">if</span> ((qt != null) &amp;&amp; (qt.objectField == null) &amp;&amp; (qt.getWeight() &gt; 0)) {
		var d = qt.getDimensions();
		var numberOfSubtrees = <span class="reserved">this</span>.power(2, d);
		<span class="reserved">for</span> (var i = 0; i &lt; numberOfSubtrees; i++) {
			<span class="reserved">for</span> (var j = 0; j &lt; d; j++) {
				qt.subtrees[i].force[j] += qt.force[j];
			}
		}
		<span class="reserved">for</span> (var i = 0; i &lt; numberOfSubtrees; i++) {
			<span class="reserved">this</span>.pushForcesDownTree(qt.subtrees[i]);
		}
	}
}


<span class="comment">///HybridVertexVertexRepulsionLaw</span>

uwm.diagram.autolayout.HybridVertexVertexRepulsionLaw = <span class="reserved">function</span>(graph, preferredEdgeLength) {
	uwm.diagram.autolayout.VertexVertexRepulsionLaw.call(<span class="reserved">this</span>, graph, preferredEdgeLength);
}

uwm.diagram.autolayout.HybridVertexVertexRepulsionLaw.<span class="reserved">prototype</span> = new uwm.diagram.autolayout.VertexVertexRepulsionLaw;

uwm.diagram.autolayout.HybridVertexVertexRepulsionLaw.<span class="reserved">prototype</span>.pairwiseRepulsion = <span class="reserved">function</span>(c1, c2) {
	var r = uwm.diagram.autolayout.Cell.<span class="reserved">prototype</span>.sumOfRadii(c1, c2);
	var k = <span class="reserved">this</span>.preferredEdgeLength + r;
	var dSquared = uwm.diagram.autolayout.Cell.<span class="reserved">prototype</span>.getDistanceSquared(c1, c2);
	<span class="reserved">if</span> (dSquared &lt; k * k) {
		<span class="reserved">return</span> k * k / dSquared;
	}
	<span class="reserved">else</span> {
		<span class="reserved">return</span> <span class="reserved">this</span>.cube(k / uwm.diagram.autolayout.Cell.<span class="reserved">prototype</span>.getDistance(c1, c2));
	}
}


<span class="comment">///ForceModel</span>

uwm.diagram.autolayout.ForceModel = <span class="reserved">function</span>(graph) {

	<span class="reserved">this</span>.graph = graph;
	<span class="reserved">this</span>.preferredEdgeLength = 0;
	<span class="reserved">this</span>.forceLaws = new draw2d.ArrayList();
	<span class="reserved">this</span>.constraints = new draw2d.ArrayList();
}

uwm.diagram.autolayout.ForceModel.<span class="reserved">prototype</span>.getPreferredEdgeLength = <span class="reserved">function</span>() {
	<span class="reserved">return</span> <span class="reserved">this</span>.preferredEdgeLength;
}

uwm.diagram.autolayout.ForceModel.<span class="reserved">prototype</span>.setPreferredEdgeLength = <span class="reserved">function</span>(k) {
	<span class="reserved">this</span>.preferredEdgeLength = k;
}

uwm.diagram.autolayout.ForceModel.<span class="reserved">prototype</span>.addForceLaw = <span class="reserved">function</span>(fl) {
	<span class="reserved">this</span>.forceLaws.add(fl);
}

uwm.diagram.autolayout.ForceModel.<span class="reserved">prototype</span>.removeForceLaw = <span class="reserved">function</span>(fl) {
	<span class="reserved">this</span>.forceLaws.remove(fl);
}

uwm.diagram.autolayout.ForceModel.<span class="reserved">prototype</span>.addConstraint = <span class="reserved">function</span>(c) {
	<span class="reserved">this</span>.constraints.add(c);
}

uwm.diagram.autolayout.ForceModel.<span class="reserved">prototype</span>.removeConstraint = <span class="reserved">function</span>(c) {
	<span class="reserved">this</span>.constraints.remove(c);
}

uwm.diagram.autolayout.ForceModel.<span class="reserved">prototype</span>.getNegativeGradient = <span class="reserved">function</span>(negativeGradient) {
	var n = <span class="reserved">this</span>.graph.numberOfVertices;
	var d = <span class="reserved">this</span>.graph.getDimensions();
	<span class="reserved">for</span> (var i = 0; i &lt; n; i++) {
		<span class="reserved">for</span> (var j = 0; j &lt; d; j++) {
			negativeGradient[i][j] = 0;
		}
		<span class="reserved">this</span>.graph.vertices.get(i).intField = i;
	}
	<span class="reserved">for</span> (var i = 0; i &lt; <span class="reserved">this</span>.forceLaws.getSize(); i++) {
		var law = <span class="reserved">this</span>.forceLaws.get(i);
		law.apply(negativeGradient);
	}
}

uwm.diagram.autolayout.ForceModel.<span class="reserved">prototype</span>.getPenaltyVector = <span class="reserved">function</span>(penaltyVector) {
	var n = <span class="reserved">this</span>.graph.numberOfVertices;
	var d = <span class="reserved">this</span>.graph.getDimensions();
	<span class="reserved">for</span> (var i = 0; i &lt; n; i++) {
		<span class="reserved">for</span> (var j = 0; j &lt; d; j++) {
			penaltyVector[i][j] = 0;
		}
		<span class="reserved">this</span>.graph.vertices.get(i).intField = i;
	}
	<span class="reserved">for</span> (var i = 0; i &lt; <span class="reserved">this</span>.constraints.getSize(); i++) {
		var constraint = <span class="reserved">this</span>.constraints.get(i);
		constraint.apply(penaltyVector);
	}
}

<span class="comment">///Constraint</span>
uwm.diagram.autolayout.Constraint = <span class="reserved">function</span>(graph) {
	uwm.diagram.autolayout.JiggleObject.call(<span class="reserved">this</span>);
	
	<span class="reserved">this</span>.graph = graph;
}

uwm.diagram.autolayout.Constraint.<span class="reserved">prototype</span> = new uwm.diagram.autolayout.JiggleObject;


<span class="comment">///ProjectionConstraint</span>
uwm.diagram.autolayout.ProjectionConstraint = <span class="reserved">function</span>(graph, dimensions) {
	uwm.diagram.autolayout.Constraint.call(<span class="reserved">this</span>, graph);
	
	<span class="reserved">this</span>.dimensions = dimensions;
}

uwm.diagram.autolayout.ProjectionConstraint.<span class="reserved">prototype</span> = new uwm.diagram.autolayout.Constraint;

uwm.diagram.autolayout.ProjectionConstraint.<span class="reserved">prototype</span>.apply = <span class="reserved">function</span>(penalty) {
	var d = <span class="reserved">this</span>.graph.getDimensions();
	var n = <span class="reserved">this</span>.graph.numberOfVertices;
	<span class="reserved">for</span> (var i = 0; i &lt; n; i++) {
		var coords = <span class="reserved">this</span>.graph.vertices.get(i).getCoords();
		<span class="reserved">for</span> (var j = <span class="reserved">this</span>.dimensions; j &lt; d; j++) {
			penalty[i][j] += (-coords[j]);
		}
	}
}

<span class="comment">///ForceDirectedOptimizationProcedure</span>

uwm.diagram.autolayout.ForceDirectedOptimizationProcedure = <span class="reserved">function</span>(graph, fm) {
	uwm.diagram.autolayout.JiggleObject.call(<span class="reserved">this</span>);
	
	<span class="reserved">this</span>.graph = graph;
	<span class="reserved">this</span>.forceModel = fm;
	
	<span class="reserved">this</span>.constrained = false;
}

uwm.diagram.autolayout.ForceDirectedOptimizationProcedure.<span class="reserved">prototype</span> = new uwm.diagram.autolayout.JiggleObject;

uwm.diagram.autolayout.ForceDirectedOptimizationProcedure.<span class="reserved">prototype</span>.getConstrained = <span class="reserved">function</span>() {
	<span class="reserved">return</span> <span class="reserved">this</span>.constrained;
}

uwm.diagram.autolayout.ForceDirectedOptimizationProcedure.<span class="reserved">prototype</span>.setConstrained = <span class="reserved">function</span>(c) {
	<span class="reserved">this</span>.constrained = c;
}

<span class="comment">///FirstOrderOptimizationProcedure</span>
<span class="comment">/** Abstract base class for first-order graph-drawing optimization procedures.
 Includes concrete method for performing adaptive line search. */</span>
uwm.diagram.autolayout.FirstOrderOptimizationProcedure = <span class="reserved">function</span>(graph, fm, accuracy) {
	uwm.diagram.autolayout.ForceDirectedOptimizationProcedure.call(<span class="reserved">this</span>, graph, fm);
	<span class="reserved">this</span>.maxCos = accuracy;
	
	<span class="reserved">this</span>.negativeGradient = null;
	<span class="reserved">this</span>.descentDirection = null;
	<span class="reserved">this</span>.penaltyVector = null;
	<span class="reserved">this</span>.penaltyFactor = 0;
	
	<span class="reserved">this</span>.stepSize = 0.1;
	<span class="reserved">this</span>.previousStepSize = 0;
	
}

uwm.diagram.autolayout.FirstOrderOptimizationProcedure.<span class="reserved">prototype</span> = new uwm.diagram.autolayout.ForceDirectedOptimizationProcedure;

uwm.diagram.autolayout.FirstOrderOptimizationProcedure.<span class="reserved">prototype</span>.improveGraph = <span class="reserved">function</span>() {
	var n = <span class="reserved">this</span>.graph.numberOfVertices;
	var d = <span class="reserved">this</span>.graph.getDimensions();
	<span class="reserved">if</span> ((<span class="reserved">this</span>.negativeGradient == null) || (<span class="reserved">this</span>.negativeGradient.length != n)) {
		<span class="reserved">this</span>.negativeGradient = new Array();
		<span class="reserved">this</span>.penaltyVector = new Array();
		<span class="reserved">for</span> (var i = 0; i &lt; n; i++) {
			<span class="reserved">this</span>.negativeGradient[i] = new Array();
			<span class="reserved">this</span>.penaltyVector[i] = new Array();
		}
		<span class="reserved">this</span>.getNegativeGradient();
	}
	<span class="reserved">this</span>.computeDescentDirection();
	<span class="reserved">return</span> <span class="reserved">this</span>.lineSearch();
}

uwm.diagram.autolayout.FirstOrderOptimizationProcedure.<span class="reserved">prototype</span>.reset = <span class="reserved">function</span>() {
	<span class="reserved">this</span>.negativeGradient = null;
	<span class="reserved">this</span>.penaltyFactor = 0;
}

uwm.diagram.autolayout.FirstOrderOptimizationProcedure.<span class="reserved">prototype</span>.computePenaltyFactor = <span class="reserved">function</span>() {
	var m1 = <span class="reserved">this</span>.l2Norm(<span class="reserved">this</span>.negativeGradient);
	var m2 = <span class="reserved">this</span>.l2Norm(<span class="reserved">this</span>.penaltyVector);
	<span class="reserved">if</span> (m2 == 0) {
		<span class="reserved">this</span>.penaltyFactor = 0;
	}
	<span class="reserved">else</span> <span class="reserved">if</span> (m1 == 0) {
		<span class="reserved">this</span>.penaltyFactor = 1;
	}
	<span class="reserved">else</span> {
		var cos = <span class="reserved">this</span>.dotProduct(<span class="reserved">this</span>.negativeGradient, <span class="reserved">this</span>.penaltyVector) / (m1 * m2);
		var penaltyFactor = Math.max(0.00000001, (0.00000001 - cos)) * Math.max(1, (m1 / m2));
	}
}

uwm.diagram.autolayout.FirstOrderOptimizationProcedure.<span class="reserved">prototype</span>.getNegativeGradient = <span class="reserved">function</span>() {
	<span class="reserved">this</span>.forceModel.getNegativeGradient(<span class="reserved">this</span>.negativeGradient);
	<span class="reserved">if</span> (<span class="reserved">this</span>.constrained) {
		<span class="reserved">this</span>.getPenaltyVector();
		<span class="reserved">this</span>.computePenaltyFactor();
		var n = <span class="reserved">this</span>.graph.numberOfVertices;
		var d = <span class="reserved">this</span>.graph.getDimensions();
		<span class="reserved">for</span> (var i = 0; i &lt; n; i++) {
			<span class="reserved">for</span> (var j = 0; j &lt; d; j++) {
				<span class="reserved">this</span>.negativeGradient[i][j] += <span class="reserved">this</span>.penaltyFactor * <span class="reserved">this</span>.penaltyVector[i][j];
			}
		}
	}
}

uwm.diagram.autolayout.FirstOrderOptimizationProcedure.<span class="reserved">prototype</span>.getPenaltyVector = <span class="reserved">function</span>() {
	<span class="reserved">this</span>.forceModel.getPenaltyVector(<span class="reserved">this</span>.penaltyVector);
}

uwm.diagram.autolayout.FirstOrderOptimizationProcedure.<span class="reserved">prototype</span>.lineSearch = <span class="reserved">function</span>() {
	<span class="reserved">this</span>.previousStepSize = 0;
	var n = <span class="reserved">this</span>.graph.numberOfVertices;
	var magDescDir = <span class="reserved">this</span>.l2Norm(<span class="reserved">this</span>.descentDirection);
	<span class="reserved">if</span> (magDescDir &lt; 0.0001) {
		<span class="reserved">return</span> 0;
	}
	var magLo = <span class="reserved">this</span>.l2Norm(<span class="reserved">this</span>.negativeGradient);
	<span class="reserved">this</span>.step();
	<span class="reserved">this</span>.getNegativeGradient();
	var magHi = <span class="reserved">this</span>.l2Norm(<span class="reserved">this</span>.negativeGradient);
	var m = magDescDir * magHi;
	var cos = <span class="reserved">this</span>.dotProduct(<span class="reserved">this</span>.negativeGradient, <span class="reserved">this</span>.descentDirection) / m;
	var lo = 0;
	var hi = Number.MAX_VALUE;
	var i = 0;
	<span class="reserved">while</span> (((cos &lt; 0) || (cos &gt; <span class="reserved">this</span>.maxCos)) &amp;&amp; (hi - lo &gt; 0.00000001)) {
		<span class="reserved">if</span> (cos &lt; 0) {
			hi = <span class="reserved">this</span>.stepSize;
			<span class="reserved">this</span>.stepSize = (lo + hi) / 2;
		}
		<span class="reserved">else</span> {
			<span class="reserved">if</span> (hi &lt; Number.MAX_VALUE) {
				lo = <span class="reserved">this</span>.stepSize;
				<span class="reserved">this</span>.stepSize = (lo + hi) / 2;
			}
			<span class="reserved">else</span> {
				lo = <span class="reserved">this</span>.stepSize;
				<span class="reserved">this</span>.stepSize *= 2;
			}
		}
		<span class="reserved">this</span>.step();
		<span class="reserved">this</span>.getNegativeGradient();
		m = magDescDir * <span class="reserved">this</span>.l2Norm(<span class="reserved">this</span>.negativeGradient);
		cos = <span class="reserved">this</span>.dotProduct(<span class="reserved">this</span>.negativeGradient, <span class="reserved">this</span>.descentDirection) / m;
	}
	<span class="reserved">return</span> <span class="reserved">this</span>.l2Norm(<span class="reserved">this</span>.negativeGradient);
}

uwm.diagram.autolayout.FirstOrderOptimizationProcedure.<span class="reserved">prototype</span>.step = <span class="reserved">function</span>() {
	var n = <span class="reserved">this</span>.graph.numberOfVertices;
	var s = <span class="reserved">this</span>.stepSize - <span class="reserved">this</span>.previousStepSize;
	<span class="reserved">for</span> (var i = 0; i &lt; n; i++) {
		<span class="reserved">this</span>.graph.vertices.get(i).translate(s, <span class="reserved">this</span>.descentDirection[i]);
	}
	<span class="reserved">this</span>.previousStepSize = <span class="reserved">this</span>.stepSize;
}

uwm.diagram.autolayout.FirstOrderOptimizationProcedure.<span class="reserved">prototype</span>.dotProduct = <span class="reserved">function</span>(u, v) {
	var n = <span class="reserved">this</span>.graph.numberOfVertices;
	var d = <span class="reserved">this</span>.graph.getDimensions();
	var sum = 0;
	<span class="reserved">for</span> (var i = 0; i &lt; n; i++) {
		<span class="reserved">for</span> (var j = 0; j &lt; d; j++) {
			sum += u[i][j] * v[i][j];
		}
	}
	<span class="reserved">return</span> sum;
}

uwm.diagram.autolayout.FirstOrderOptimizationProcedure.<span class="reserved">prototype</span>.l2Norm = <span class="reserved">function</span>(vect) {
	<span class="reserved">return</span> Math.sqrt(<span class="reserved">this</span>.dotProduct(vect, vect));
}

uwm.diagram.autolayout.FirstOrderOptimizationProcedure.<span class="reserved">prototype</span>.lInfinityNorm = <span class="reserved">function</span>(vect) {
	var n = <span class="reserved">this</span>.graph.numberOfVertices;
	var d = <span class="reserved">this</span>.graph.getDimensions();
	var max = 0;
	<span class="reserved">for</span> (var i = 0; i &lt; n; i++) {
		<span class="reserved">for</span> (var j = 0; j &lt; d; j++) {
			max = Math.max(max, Math.abs(vect[i][j]));
		}
	}
	<span class="reserved">return</span> max;
}

<span class="comment">///ConjugateGradients</span>
<span class="comment">/** Class for conjugate gradient method. */</span>

uwm.diagram.autolayout.ConjugateGradients = <span class="reserved">function</span>(graph, fm, accuracy, restartThreshold) {
	uwm.diagram.autolayout.FirstOrderOptimizationProcedure.call(<span class="reserved">this</span>, graph, fm, accuracy);
	
	<span class="reserved">this</span>.magnitudeOfPreviousGradientSquared = null;
	<span class="reserved">this</span>.previousDescentDirection = null;
	<span class="reserved">this</span>.restartThreshold = 0;
	
	<span class="reserved">if</span> (restartThreshold) {
		<span class="reserved">this</span>.restartThreshold = restartThreshold;
	}
}

uwm.diagram.autolayout.ConjugateGradients.<span class="reserved">prototype</span> = new uwm.diagram.autolayout.FirstOrderOptimizationProcedure;


uwm.diagram.autolayout.ConjugateGradients.<span class="reserved">prototype</span>.reset = <span class="reserved">function</span>() {
	<span class="reserved">this</span>.negativeGradient = null;
	<span class="reserved">this</span>.descentDirection = null;
}

uwm.diagram.autolayout.ConjugateGradients.<span class="reserved">prototype</span>.computeDescentDirection = <span class="reserved">function</span>() {
	var n = <span class="reserved">this</span>.graph.numberOfVertices;
	var d = <span class="reserved">this</span>.graph.getDimensions();
	var magnitudeOfCurrentGradientSquared = 0;
	<span class="reserved">if</span> ((<span class="reserved">this</span>.descentDirection == null) || (<span class="reserved">this</span>.descentDirection.length != n)) {
		<span class="reserved">this</span>.descentDirection = new Array();
		<span class="reserved">this</span>.previousDescentDirection = new Array();
		<span class="reserved">for</span> (var i = 0; i &lt; n; i++) {
			<span class="reserved">this</span>.descentDirection[i] = new Array();
			<span class="reserved">this</span>.previousDescentDirection[i] = new Array();
			<span class="reserved">for</span> (var j = 0; j &lt; d; j++) {
				var temp = <span class="reserved">this</span>.negativeGradient[i][j];
				<span class="reserved">this</span>.descentDirection[i][j] = temp;
				magnitudeOfCurrentGradientSquared += <span class="reserved">this</span>.square(temp);
			}
		}
	}
	<span class="reserved">else</span> {
		<span class="reserved">for</span> (var i = 0; i &lt; n; i++) {
			<span class="reserved">for</span> (var j = 0; j &lt; d; j++) {
				var temp = <span class="reserved">this</span>.negativeGradient[i][j];
				magnitudeOfCurrentGradientSquared += <span class="reserved">this</span>.square(temp);
			}
		}
		<span class="reserved">if</span> (magnitudeOfCurrentGradientSquared &lt; 0.000001) {
			<span class="reserved">for</span> (var i = 0; i &lt; n; i++) {
				<span class="reserved">for</span> (var j = 0; j &lt; d; j++) {
					<span class="reserved">this</span>.previousDescentDirection[i][j] = 0;
					<span class="reserved">this</span>.descentDirection[i][j] = 0;
				}
			}
			<span class="reserved">return</span>;
		}
		var w = magnitudeOfCurrentGradientSquared / <span class="reserved">this</span>.magnitudeOfPreviousGradientSquared;
		var dotProduct = 0;
		var magnitudeOfDescentDirectionSquared = 0;
		var m;
		<span class="reserved">for</span> (var i = 0; i &lt; n; i++) {
			<span class="reserved">for</span> (var j = 0; j &lt; d; j++) {
				<span class="reserved">this</span>.descentDirection[i][j] = <span class="reserved">this</span>.negativeGradient[i][j] +
				w * <span class="reserved">this</span>.previousDescentDirection[i][j];
				dotProduct += <span class="reserved">this</span>.descentDirection[i][j] * <span class="reserved">this</span>.negativeGradient[i][j];
				magnitudeOfDescentDirectionSquared += <span class="reserved">this</span>.square(<span class="reserved">this</span>.descentDirection[i][j]);
			}
		}
		m = magnitudeOfCurrentGradientSquared * magnitudeOfDescentDirectionSquared;
		<span class="reserved">if</span> (dotProduct / Math.sqrt(m) &lt; <span class="reserved">this</span>.restartThreshold) {
			<span class="reserved">this</span>.descentDirection = null;
			<span class="reserved">this</span>.computeDescentDirection();
			<span class="reserved">return</span>;
		}
	}
	<span class="reserved">this</span>.magnitudeOfPreviousGradientSquared = magnitudeOfCurrentGradientSquared;
	<span class="reserved">for</span> (var i = 0; i &lt; n; i++) {
		<span class="reserved">for</span> (var j = 0; j &lt; d; j++) {
			<span class="reserved">this</span>.previousDescentDirection[i][j] = <span class="reserved">this</span>.descentDirection[i][j];
		}
	}
}

<span class="comment">///Cell</span>

<span class="comment">/** Abstract base class for all JIGGLE objects that have rectangular
 representations.  Known subclasses: Vertex, EdgeLabel, QuadTree. */</span>
uwm.diagram.autolayout.Cell = <span class="reserved">function</span>() {
	uwm.diagram.autolayout.JiggleObject.call(<span class="reserved">this</span>);
	
	<span class="reserved">this</span>.dimensions = 2; <span class="comment">/* default is a 2-D cell */</span>
	<span class="reserved">this</span>.weight = 0; <span class="comment">/* weight of cell */</span>
	<span class="reserved">this</span>.coords = null; <span class="comment">/* coordinates of center of cell */</span>
	<span class="reserved">this</span>.min = null;
	<span class="reserved">this</span>.max = null; <span class="comment">/* bounding box of cell */</span>
	<span class="reserved">this</span>.size = null; <span class="comment">/* dimensions of cell */</span>
	<span class="reserved">this</span>.setDimensions(2);
}

uwm.diagram.autolayout.Cell.<span class="reserved">prototype</span> = new uwm.diagram.autolayout.JiggleObject;

uwm.diagram.autolayout.Cell.<span class="reserved">prototype</span>.getWeight = <span class="reserved">function</span>() {
	<span class="reserved">return</span> <span class="reserved">this</span>.weight;
}

uwm.diagram.autolayout.Cell.<span class="reserved">prototype</span>.setWeight = <span class="reserved">function</span>(w) {
	<span class="reserved">this</span>.weight = w;
}

uwm.diagram.autolayout.Cell.<span class="reserved">prototype</span>.getDimensions = <span class="reserved">function</span>() {
	<span class="reserved">return</span> <span class="reserved">this</span>.dimensions;
}

uwm.diagram.autolayout.Cell.<span class="reserved">prototype</span>.setDimensions = <span class="reserved">function</span>(d) {
	<span class="reserved">this</span>.dimensions = d;
	<span class="reserved">this</span>.coords = new Array();
	<span class="reserved">this</span>.size = new Array();
	<span class="reserved">this</span>.min = new Array();
	<span class="reserved">this</span>.max = new Array();
}

uwm.diagram.autolayout.Cell.<span class="reserved">prototype</span>.getCoords = <span class="reserved">function</span>() {
	<span class="reserved">return</span> <span class="reserved">this</span>.coords;
}

uwm.diagram.autolayout.Cell.<span class="reserved">prototype</span>.setCoords = <span class="reserved">function</span>(c) {
	<span class="reserved">for</span> (var i = 0; i &lt; <span class="reserved">this</span>.dimensions; i++) {
		<span class="reserved">this</span>.coords[i] = c[i];
	}
}

uwm.diagram.autolayout.Cell.<span class="reserved">prototype</span>.getMin = <span class="reserved">function</span>() {
	<span class="reserved">return</span> <span class="reserved">this</span>.min;
}

uwm.diagram.autolayout.Cell.<span class="reserved">prototype</span>.setMin = <span class="reserved">function</span>(c) {
	<span class="reserved">for</span> (var i = 0; i &lt; <span class="reserved">this</span>.dimensions; i++) {
		<span class="reserved">this</span>.min[i] = c[i];
	}
	<span class="reserved">this</span>.recomputeSize();
}

uwm.diagram.autolayout.Cell.<span class="reserved">prototype</span>.getMax = <span class="reserved">function</span>() {
	<span class="reserved">return</span> <span class="reserved">this</span>.max;
}

uwm.diagram.autolayout.Cell.<span class="reserved">prototype</span>.setMax = <span class="reserved">function</span>(c) {
	<span class="reserved">for</span> (var i = 0; i &lt; <span class="reserved">this</span>.dimensions; i++) {
		<span class="reserved">this</span>.max[i] = c[i];
	}
	<span class="reserved">this</span>.recomputeSize();
}

uwm.diagram.autolayout.Cell.<span class="reserved">prototype</span>.recomputeSize = <span class="reserved">function</span>() {
	<span class="reserved">for</span> (var i = 0; i &lt; <span class="reserved">this</span>.dimensions; i++) {
		<span class="reserved">this</span>.size[i] = <span class="reserved">this</span>.max[i] - <span class="reserved">this</span>.min[i];
	}
}

uwm.diagram.autolayout.Cell.<span class="reserved">prototype</span>.getSize = <span class="reserved">function</span>() {
	<span class="reserved">return</span> <span class="reserved">this</span>.size;
}

uwm.diagram.autolayout.Cell.<span class="reserved">prototype</span>.setSize = <span class="reserved">function</span>(c) {
	<span class="reserved">for</span> (var i = 0; i &lt; <span class="reserved">this</span>.dimensions; i++) {
		<span class="reserved">this</span>.size[i] = c[i];
	}
	<span class="reserved">this</span>.recomputeBoundaries();
}

uwm.diagram.autolayout.Cell.<span class="reserved">prototype</span>.recomputeBoundaries = <span class="reserved">function</span>() {
	<span class="reserved">for</span> (var i = 0; i &lt; <span class="reserved">this</span>.dimensions; i++) {
		<span class="reserved">this</span>.min[i] = <span class="reserved">this</span>.coords[i] - <span class="reserved">this</span>.size[i] / 2;
		<span class="reserved">this</span>.max[i] = <span class="reserved">this</span>.coords[i] + <span class="reserved">this</span>.size[i] / 2;
	}
}

uwm.diagram.autolayout.Cell.<span class="reserved">prototype</span>.translate = <span class="reserved">function</span>(scalar, vector) {
	<span class="reserved">if</span> (!vector) {
		scalar = vector;
		scalar = 1;
	}
	
	<span class="reserved">for</span> (var i = 0; i &lt; <span class="reserved">this</span>.dimensions; i++) {
		var translation = scalar * vector[i];
		<span class="reserved">this</span>.coords[i] += translation;
		<span class="reserved">this</span>.min[i] += translation;
		<span class="reserved">this</span>.max[i] += translation;
	}
}

uwm.diagram.autolayout.Cell.<span class="reserved">prototype</span>.getDistanceSquared = <span class="reserved">function</span>(c1, c2) {
	var sum = 0;
	var d = c1.getDimensions();
	<span class="reserved">for</span> (var i = 0; i &lt; d; i++) 
		sum += <span class="reserved">this</span>.square(c1.coords[i] - c2.coords[i]);
	<span class="reserved">return</span> sum;
}

uwm.diagram.autolayout.Cell.<span class="reserved">prototype</span>.getDistanceSquaredPoint = <span class="reserved">function</span>(cell, point) {
	var sum = 0;
	var d = cell.getDimensions();
	<span class="reserved">for</span> (var i = 0; i &lt; d; i++) 
		sum += <span class="reserved">this</span>.square(cell.coords[i] - point[i]);
	<span class="reserved">return</span> sum;
}

uwm.diagram.autolayout.Cell.<span class="reserved">prototype</span>.getDistance = <span class="reserved">function</span>(c1, c2) {
	<span class="reserved">return</span> Math.sqrt(<span class="reserved">this</span>.getDistanceSquared(c1, c2));
}

uwm.diagram.autolayout.Cell.<span class="reserved">prototype</span>.getDistancePoint = <span class="reserved">function</span>(cell, point) {
	<span class="reserved">return</span> Math.sqrt(<span class="reserved">this</span>.getDistanceSquaredPoint(cell, point));
}

uwm.diagram.autolayout.Cell.<span class="reserved">prototype</span>.sumOfRadii = <span class="reserved">function</span>(c1, c2) {
	var d = c1.getDimensions();
	var coords1 = c1.getCoords();
	var coords2 = c2.getCoords();
	var seg = new Array();
	<span class="reserved">for</span> (var i = 0; i &lt; d; i++) {
		seg[i] = coords2[i] - coords1[i];
	}
	<span class="reserved">return</span> <span class="reserved">this</span>.radiusSegment(d, c1.getSize(), seg) + <span class="reserved">this</span>.radiusSegment(d, c2.getSize(), seg);
}

uwm.diagram.autolayout.Cell.<span class="reserved">prototype</span>.radius = <span class="reserved">function</span>(cell, point) {
	var d = cell.getDimensions();
	var coords = cell.getCoords();
	var seg = new Array();
	<span class="reserved">for</span> (var i = 0; i &lt; d; i++) {
		seg[i] = point[i] - coords[i];
	}
	<span class="reserved">return</span> <span class="reserved">this</span>.radiusSegment(d, cell.getSize(), seg);
}


uwm.diagram.autolayout.Cell.<span class="reserved">prototype</span>.radiusSegment = <span class="reserved">function</span>(d, cellSize, segment) {
	var sum = 0;
	<span class="reserved">for</span> (var i = 0; i &lt; d; i++) {
		sum += cellSize[i];
	}
	<span class="reserved">if</span> (sum == 0) {
		<span class="reserved">return</span> 0;
	}
	var t = Number.MAX_VALUE;
	<span class="reserved">for</span> (var i = 0; i &lt; d; i++) {
		t = Math.min(t, Math.abs(cellSize[i] / segment[i]));
	}
	var lengthSquared = 0;
	<span class="reserved">for</span> (var i = 0; i &lt; d; i++) {
		lengthSquared += <span class="reserved">this</span>.square(t * segment[i]);
	}
	<span class="reserved">return</span> Math.sqrt(lengthSquared) / 2;
}

<span class="comment">///QuadTree</span>

uwm.diagram.autolayout.QuadTree = <span class="reserved">function</span>(graph, max, parent) {
	uwm.diagram.autolayout.Cell.call(<span class="reserved">this</span>);
	
	<span class="reserved">this</span>.objectField = null;
	<span class="reserved">this</span>.subtrees = new Array();
	
	var d;
	
	<span class="reserved">if</span> (!max) {
		<span class="reserved">this</span>.setContext(graph);
		d = graph.getDimensions();
		<span class="reserved">this</span>.setDimensions(d);
		var n = graph.numberOfVertices;
		<span class="reserved">this</span>.setMin(graph.getMin());
		<span class="reserved">this</span>.setMax(graph.getMax());
		<span class="reserved">for</span> (var i = 0; i &lt; n; i++) {
			graph.vertices.get(i).objectField = null;
		}
		<span class="reserved">for</span> (var i = 0; i &lt; n; i++) {
			<span class="reserved">this</span>.insert(graph.vertices.get(i));
		}
	}
	<span class="reserved">else</span> {
		<span class="comment">//graph == min</span>
		<span class="reserved">this</span>.setContext(parent);
		d = parent.getDimensions();
		<span class="reserved">this</span>.setDimensions(d);
		<span class="reserved">this</span>.setMin(graph);
		<span class="reserved">this</span>.setMax(max);
	}
	
	<span class="reserved">this</span>.force = new Array();
	<span class="reserved">for</span> (var i = 0; i &lt; d; i++) {
		<span class="reserved">this</span>.force[i] = 0;
	}
}

uwm.diagram.autolayout.QuadTree.<span class="reserved">prototype</span> = new uwm.diagram.autolayout.Cell;

uwm.diagram.autolayout.QuadTree.<span class="reserved">prototype</span>.lookUp = <span class="reserved">function</span>(v) {
	<span class="reserved">if</span> (<span class="reserved">this</span>.objectField == v) {
		<span class="reserved">return</span> <span class="reserved">this</span>;
	}
	<span class="reserved">else</span> <span class="reserved">if</span> (<span class="reserved">this</span>.objectField != null) {
		<span class="reserved">return</span> null;
	}
	<span class="reserved">else</span> {
		<span class="reserved">return</span> <span class="reserved">this</span>.subtrees[<span class="reserved">this</span>.getIndex(v)].lookUp(v);
	}
}

uwm.diagram.autolayout.QuadTree.<span class="reserved">prototype</span>.getIndex = <span class="reserved">function</span>(v) {
	var c = v.getCoords();
	var center = <span class="reserved">this</span>.getCenter();
	var d = <span class="reserved">this</span>.getDimensions();
	var index = 0
	var column = 1;
	<span class="reserved">for</span> (var i = 0; i &lt; d; i++) {
		<span class="reserved">if</span> (c[i] &gt; center[i]) {
			index += column;
		}
		column *= 2;
	}
	
	<span class="reserved">return</span> index;
}

uwm.diagram.autolayout.QuadTree.<span class="reserved">prototype</span>.getCenter = <span class="reserved">function</span>() {
	var d = <span class="reserved">this</span>.getDimensions();
	var mp = new Array();
	var lo = <span class="reserved">this</span>.getMin();
	var hi = <span class="reserved">this</span>.getMax();
	<span class="reserved">for</span> (var i = 0; i &lt; d; i++) {
		mp[i] = (lo[i] + hi[i]) / 2;
	}
	<span class="reserved">return</span> mp;
}

uwm.diagram.autolayout.QuadTree.<span class="reserved">prototype</span>.recomputeSize = <span class="reserved">function</span>() {

}

uwm.diagram.autolayout.QuadTree.<span class="reserved">prototype</span>.recomputeBoundaries = <span class="reserved">function</span>() {

}
<span class="comment">/* NOTE: Size for quadtrees has nothing to do with min and max! It stores
 the average size of the vertices that have been inserted into the tree. */</span>
uwm.diagram.autolayout.QuadTree.<span class="reserved">prototype</span>.insert = <span class="reserved">function</span>(v) {
	var w = <span class="reserved">this</span>.getWeight();
	var vw = v.getWeight();
	var d = <span class="reserved">this</span>.getDimensions();
	var vCoords = v.getCoords();
	var vSize = v.getSize();
	<span class="reserved">if</span> (w == 0) {
		v.setContext(<span class="reserved">this</span>);
		<span class="reserved">this</span>.setWeight(v.getWeight());
		<span class="reserved">this</span>.setCoords(vCoords);
		<span class="reserved">this</span>.setSize(v.getSize());
		<span class="reserved">this</span>.objectField = v;
		<span class="reserved">return</span>;
	}
	<span class="reserved">if</span> (<span class="reserved">this</span>.objectField != null) {
		<span class="reserved">this</span>.splitCell();
	}
	var c = <span class="reserved">this</span>.getCoords();
	var s = <span class="reserved">this</span>.getSize();
	<span class="reserved">for</span> (var i = 0; i &lt; d; i++) {
		c[i] = (c[i] * w + vCoords[i] * vw) / (w + vw);
		s[i] = (s[i] * w + vSize[i] * vw) / (w + vw);
	}
	<span class="reserved">this</span>.setWeight(w + vw);
	<span class="reserved">this</span>.subtrees[<span class="reserved">this</span>.getIndex(v)].insert(v);
}

uwm.diagram.autolayout.QuadTree.<span class="reserved">prototype</span>.splitCell = <span class="reserved">function</span>() {
	var v = <span class="reserved">this</span>.objectField;
	<span class="reserved">this</span>.objectField = null;
	var cellMin = <span class="reserved">this</span>.getMin();
	var cellMax = <span class="reserved">this</span>.getMax();
	var center = <span class="reserved">this</span>.getCenter();
	var d = <span class="reserved">this</span>.getDimensions();
	var n = <span class="reserved">this</span>.power(2, d);
	var lo = new Array();
	var hi = new Array();
	<span class="reserved">for</span> (var index = 0; index &lt; n; index++) {
		var column = 1;
		<span class="reserved">for</span> (var i = 0; i &lt; d; i++) {
			<span class="reserved">if</span> ((index &amp; column) &gt; 0) {
				lo[i] = center[i];
				hi[i] = cellMax[i];
			}
			<span class="reserved">else</span> {
				lo[i] = cellMin[i];
				hi[i] = center[i];
			}
			column *= 2;
		}
		<span class="reserved">this</span>.subtrees[index] = new uwm.diagram.autolayout.QuadTree(lo, hi, <span class="reserved">this</span>);
	}
	<span class="reserved">this</span>.subtrees[<span class="reserved">this</span>.getIndex(v)].insert(v);
}

<span class="comment">///Vertex</span>

<span class="comment">/** Class for vertices of a graph. */</span>
uwm.diagram.autolayout.Vertex = <span class="reserved">function</span>(graph) {
	uwm.diagram.autolayout.Cell.call(<span class="reserved">this</span>);
	
	<span class="reserved">this</span>.undirectedDegree = 0;
	<span class="reserved">this</span>.inDegree = 0
	<span class="reserved">this</span>.outDegree = 0;
	<span class="reserved">this</span>.undirectedEdges = new draw2d.ArrayList();
	<span class="reserved">this</span>.inEdges = new draw2d.ArrayList();
	<span class="reserved">this</span>.outEdges = new draw2d.ArrayList();
	<span class="reserved">this</span>.undirectedNeighbors = new draw2d.ArrayList();
	<span class="reserved">this</span>.inNeighbors = new draw2d.ArrayList();
	<span class="reserved">this</span>.outNeighbors = new draw2d.ArrayList();
	
	<span class="comment">/* NOTE: the above are made package-accessible for reasons of
	 efficiency.  They should NOT, however, be modified except by
	 insertNeighbor and deleteNeighbor methods below. */</span>
	<span class="reserved">this</span>.name = <span class="literal">""</span>; <span class="comment">/* name of vertex */</span>
	<span class="reserved">this</span>.fixed = false; <span class="comment">/* is the vertex anchored? */</span>
	<span class="reserved">this</span>.setContext(graph);
	<span class="reserved">this</span>.setWeight(1);
	<span class="reserved">this</span>.setDimensions(graph.getDimensions());
}

uwm.diagram.autolayout.Vertex.<span class="reserved">prototype</span> = new uwm.diagram.autolayout.Cell;

uwm.diagram.autolayout.Vertex.<span class="reserved">prototype</span>.getName = <span class="reserved">function</span>() {
	<span class="reserved">return</span> <span class="reserved">this</span>.name;
}

uwm.diagram.autolayout.Vertex.<span class="reserved">prototype</span>.setName = <span class="reserved">function</span>(str) {
	<span class="reserved">this</span>.name = str;
}

uwm.diagram.autolayout.Vertex.<span class="reserved">prototype</span>.getFixed = <span class="reserved">function</span>() {
	<span class="reserved">return</span> <span class="reserved">this</span>.fixed;
}

uwm.diagram.autolayout.Vertex.<span class="reserved">prototype</span>.setFixed = <span class="reserved">function</span>(f) {
	<span class="reserved">this</span>.fixed = f;
}

uwm.diagram.autolayout.Vertex.<span class="reserved">prototype</span>.insertNeighbor = <span class="reserved">function</span>(e) {
	var from = e.getFrom();
	var to = e.getTo();
	var v = null;
	<span class="reserved">if</span> (<span class="reserved">this</span> == from) {
		v = to;
	}
	<span class="reserved">else</span> <span class="reserved">if</span> (<span class="reserved">this</span> == to) {
		v = from;
	}
	<span class="reserved">else</span> {
		throw new uwm.diagram.autolayout.Error(e + <span class="literal">" not incident to "</span> + <span class="reserved">this</span>);
	}
	<span class="reserved">if</span> (!e.getDirected()) {
		<span class="reserved">this</span>.undirectedEdges.add(e);
		<span class="reserved">this</span>.undirectedNeighbors.add(v);
		<span class="reserved">this</span>.undirectedDegree++;
	}
	<span class="reserved">else</span> <span class="reserved">if</span> (<span class="reserved">this</span> == from) {
		<span class="reserved">this</span>.outEdges.add(e);
		<span class="reserved">this</span>.outNeighbors.add(to);
		<span class="reserved">this</span>.outDegree++;
	}
	<span class="reserved">else</span> {
		<span class="reserved">this</span>.inEdges.add(e);
		<span class="reserved">this</span>.inNeighbors.add(from);
		<span class="reserved">this</span>.inDegree++;
	}
}

uwm.diagram.autolayout.Vertex.<span class="reserved">prototype</span>.deleteNeighbor = <span class="reserved">function</span>(e) {
	var from = e.getFrom();
	var to = e.getTo();
	var v = null;
	<span class="reserved">if</span> (<span class="reserved">this</span> == from) {
		v = to;
	}
	<span class="reserved">else</span> <span class="reserved">if</span> (<span class="reserved">this</span> == to) {
		v = from;
	}
	<span class="reserved">else</span> {
		throw new uwm.diagram.autolayout.Error(e + <span class="literal">" not incident to "</span> + <span class="reserved">this</span>);
	}
	try {
		<span class="reserved">if</span> (!e.getDirected()) {
			<span class="reserved">this</span>.undirectedEdges.remove(e);
			<span class="reserved">this</span>.undirectedNeighbors.remove(v);
			<span class="reserved">this</span>.undirectedDegree--;
		}
		<span class="reserved">else</span> <span class="reserved">if</span> (<span class="reserved">this</span> == from) {
			<span class="reserved">this</span>.outEdges.remove(e);
			<span class="reserved">this</span>.outNeighbors.remove(to);
			<span class="reserved">this</span>.outDegree--;
		}
		<span class="reserved">else</span> {
			<span class="reserved">this</span>.inEdges.remove(e);
			<span class="reserved">this</span>.inNeighbors.remove(from);
			<span class="reserved">this</span>.inDegree--;
		}
	} 
	catch (exc) {
		throw new uwm.diagram.autolayout.Error(e + <span class="literal">" not incident to "</span> + <span class="reserved">this</span>);
	}
}

uwm.diagram.autolayout.Vertex.<span class="reserved">prototype</span>.toString = <span class="reserved">function</span>() {
	<span class="reserved">return</span> <span class="literal">"(Vertex: "</span> + <span class="reserved">this</span>.name + <span class="literal">")"</span>;
}

<span class="comment">///Edge</span>

<span class="comment">/** Class for edges of a graph.  NOTE: the only mutable characteristics
 of an edge are its label, directedness, and preferred length. */</span>
uwm.diagram.autolayout.Edge = <span class="reserved">function</span>(graph, from, to, directed) {
	uwm.diagram.autolayout.JiggleObject.call(<span class="reserved">this</span>);
	
	<span class="reserved">this</span>.from = from;
	<span class="reserved">this</span>.to = to; <span class="comment">/* endpoints of the edge */</span>
	<span class="reserved">this</span>.label = null; <span class="comment">/* label of edge */</span>
	<span class="reserved">this</span>.directed = false; <span class="comment">/* is the edge directed? */</span>
	<span class="reserved">if</span> (directed) {
		<span class="reserved">this</span>.directed = directed;
	}
	<span class="reserved">this</span>.preferredLength = 0; <span class="comment">/* preferred length of edge */</span>
	<span class="reserved">this</span>.setContext(graph);
}

uwm.diagram.autolayout.Edge.<span class="reserved">prototype</span> = new uwm.diagram.autolayout.JiggleObject;

uwm.diagram.autolayout.Edge.<span class="reserved">prototype</span>.getFrom = <span class="reserved">function</span>() {
	<span class="reserved">return</span> <span class="reserved">this</span>.from;
}

uwm.diagram.autolayout.Edge.<span class="reserved">prototype</span>.getTo = <span class="reserved">function</span>() {
	<span class="reserved">return</span> <span class="reserved">this</span>.to;
}

uwm.diagram.autolayout.Edge.<span class="reserved">prototype</span>.getLabel = <span class="reserved">function</span>() {
	<span class="reserved">return</span> <span class="reserved">this</span>.label;
}

uwm.diagram.autolayout.Edge.<span class="reserved">prototype</span>.setLabel = <span class="reserved">function</span>(lbl) {
	<span class="reserved">this</span>.label = lbl;
}

uwm.diagram.autolayout.Edge.<span class="reserved">prototype</span>.getDirected = <span class="reserved">function</span>() {
	<span class="reserved">return</span> <span class="reserved">this</span>.directed;
}

uwm.diagram.autolayout.Edge.<span class="reserved">prototype</span>.setDirected = <span class="reserved">function</span>(d) {
	<span class="reserved">this</span>.directed = d;
}

uwm.diagram.autolayout.Edge.<span class="reserved">prototype</span>.getPreferredLength = <span class="reserved">function</span>() {
	<span class="reserved">return</span> <span class="reserved">this</span>.preferredLength;
}

uwm.diagram.autolayout.Edge.<span class="reserved">prototype</span>.setPreferredLength = <span class="reserved">function</span>(len) {
	<span class="reserved">this</span>.preferredLength = len;
}

uwm.diagram.autolayout.Edge.<span class="reserved">prototype</span>.getLengthSquared = <span class="reserved">function</span>() {
	<span class="reserved">return</span> uwm.diagram.autolayout.Vertex.<span class="reserved">prototype</span>.getDistanceSquared(<span class="reserved">this</span>.from, <span class="reserved">this</span>.to);
}

uwm.diagram.autolayout.Edge.<span class="reserved">prototype</span>.getLength = <span class="reserved">function</span>() {
	<span class="reserved">return</span> uwm.diagram.autolayout.Vertex.<span class="reserved">prototype</span>.getDistance(<span class="reserved">this</span>.from, <span class="reserved">this</span>.to);
}

uwm.diagram.autolayout.Edge.<span class="reserved">prototype</span>.toString = <span class="reserved">function</span>() {
	<span class="reserved">return</span> <span class="literal">"(Edge: "</span> + <span class="reserved">this</span>.from + <span class="literal">", "</span> + <span class="reserved">this</span>.to + <span class="literal">", "</span> +
	(<span class="reserved">this</span>.directed ? <span class="literal">"directed"</span> : <span class="literal">"undirected"</span>) +
	<span class="literal">")"</span>;
}

<span class="comment">///EdgeLabel</span>

<span class="comment">/** Class for edge labels. */</span>
uwm.diagram.autolayout.EdgeLabel = <span class="reserved">function</span>(edge, name) {
	uwm.diagram.autolayout.Cell.call(<span class="reserved">this</span>);
	
	<span class="reserved">this</span>.name = name;
	<span class="reserved">this</span>.setContext(e)
}

uwm.diagram.autolayout.EdgeLabel.<span class="reserved">prototype</span> = new uwm.diagram.autolayout.Cell;

uwm.diagram.autolayout.EdgeLabel.<span class="reserved">prototype</span>.getName = <span class="reserved">function</span>() {
	<span class="reserved">return</span> <span class="reserved">this</span>.name;
}

uwm.diagram.autolayout.EdgeLabel.<span class="reserved">prototype</span>.setName = <span class="reserved">function</span>(str) {
	<span class="reserved">this</span>.name = str;
}

uwm.diagram.autolayout.EdgeLabel.<span class="reserved">prototype</span>.toString = <span class="reserved">function</span>() {
	<span class="reserved">return</span> <span class="literal">"(EdgeLabel: "</span> + <span class="reserved">this</span>.name + <span class="literal">")"</span>;
}

<span class="comment">///Graph</span>

<span class="comment">/** Class for graphs. */</span>
uwm.diagram.autolayout.Graph = <span class="reserved">function</span>(dimensions) {
	uwm.diagram.autolayout.Cell.call(<span class="reserved">this</span>);
	
	<span class="reserved">this</span>.numberOfVertices = 0;
	<span class="reserved">this</span>.numberOfMarkedVertices = 0;
	<span class="reserved">this</span>.numberOfEdges = 0;
	<span class="reserved">this</span>.vertices = new draw2d.ArrayList();
	<span class="reserved">this</span>.edges = new draw2d.ArrayList();
	
	<span class="comment">/* NOTE: the above are made publicly accessible for reasons of
	 efficiency.  They should NOT, however, be modified except by
	 insertVertex, deleteVertex, insertEdge, and deleteEdge methods
	 below. */</span>
	<span class="reserved">if</span> (dimensions) {
		<span class="reserved">this</span>.setDimensions(dimensions);
	}
}

uwm.diagram.autolayout.Graph.<span class="reserved">prototype</span> = new uwm.diagram.autolayout.Cell;

uwm.diagram.autolayout.Graph.<span class="reserved">prototype</span>.insertVertex = <span class="reserved">function</span>() {
	var v = new uwm.diagram.autolayout.Vertex(<span class="reserved">this</span>);
	<span class="reserved">this</span>.vertices.add(v);
	<span class="reserved">this</span>.numberOfVertices++;
	<span class="reserved">return</span> v;
}

uwm.diagram.autolayout.Graph.<span class="reserved">prototype</span>.insertEdge = <span class="reserved">function</span>(from, to, dir) {
	<span class="reserved">if</span> (!dir) {
		dir = false;
	}
	
	var e = new uwm.diagram.autolayout.Edge(<span class="reserved">this</span>, from, to, dir);
	from.insertNeighbor(e);
	to.insertNeighbor(e);
	<span class="reserved">this</span>.edges.add(e);
	<span class="reserved">this</span>.numberOfEdges++;
	<span class="reserved">return</span> e;
}

uwm.diagram.autolayout.Graph.<span class="reserved">prototype</span>.deleteVertex = <span class="reserved">function</span>(v) {
	try {
		<span class="reserved">for</span> (var i = 0; i &lt; v.inDegree; i++) {
			var e = v.undirectedEdges.get(i);
			v.undirectedNeighbors.get(i).deleteNeighbor(e);
			<span class="reserved">this</span>.edges.remove(e);
			<span class="reserved">this</span>.numberOfEdges--;
		}
		<span class="reserved">for</span> (var i = 0; i &lt; v.inDegree; i++) {
			var e = v.inEdges.get(i);
			v.inNeighbors.get(i).deleteNeighbor(e);
			<span class="reserved">this</span>.edges.remove(e);
			<span class="reserved">this</span>.numberOfEdges--;
		}
		<span class="reserved">for</span> (var i = 0; i &lt; v.outDegree; i++) {
			var e = v.outEdges.get(i);
			v.outNeighbors.get(i).deleteNeighbor(e);
			<span class="reserved">this</span>.edges.remove(e);
			<span class="reserved">this</span>.numberOfEdges--;
		}
		<span class="reserved">this</span>.vertices.remove(v);
		<span class="reserved">this</span>.numberOfVertices--;
	} 
	catch (exc) {
		throw new uwm.diagram.autolayout.Error(v + <span class="literal">" not found"</span>);
	}
}

uwm.diagram.autolayout.Graph.<span class="reserved">prototype</span>.deleteEdge = <span class="reserved">function</span>(e) {
	try {
		e.getFrom().deleteNeighbor(e);
		e.getTo().deleteNeighbor(e);
		<span class="reserved">this</span>.edges.remove(e);
		<span class="reserved">this</span>.numberOfEdges--;
	} 
	catch (exc) {
		throw new uwm.diagram.autolayout.Error(e + <span class="literal">" not found"</span>);
	}
}

uwm.diagram.autolayout.Graph.<span class="reserved">prototype</span>.recomputeBoundaries = <span class="reserved">function</span>() {
	var d = <span class="reserved">this</span>.getDimensions();
	var lo = <span class="reserved">this</span>.getMin();
	var hi = <span class="reserved">this</span>.getMax();
	<span class="reserved">for</span> (var i = 0; i &lt; d; i++) {
		lo[i] = Number.MAX_VALUE;
		hi[i] = -Number.MAX_VALUE;
	}
	<span class="reserved">for</span> (var i = 0; i &lt; <span class="reserved">this</span>.numberOfVertices; i++) {
		var v = <span class="reserved">this</span>.vertices.get(i);
		var c = v.getCoords();
		<span class="reserved">for</span> (var j = 0; j &lt; d; j++) {
			lo[j] = Math.min(lo[j], c[j]);
			hi[j] = Math.max(hi[j], c[j]);
		}
	}
	<span class="reserved">this</span>.recomputeSize();
}

<span class="comment">/**The isConnected method tests whether a graph is connected.
 An empty graph is considered to be not connected.*/</span>
uwm.diagram.autolayout.Graph.<span class="reserved">prototype</span>.isConnected = <span class="reserved">function</span>() {
	<span class="reserved">if</span> (<span class="reserved">this</span>.numberOfVertices == 0) {
		<span class="reserved">return</span> false;
	}
	<span class="reserved">for</span> (var i = 0; i &lt; <span class="reserved">this</span>.numberOfVertices; i++) {
		<span class="reserved">this</span>.vertices.get(i).booleanField = false;
	}
	<span class="reserved">this</span>.numberOfMarkedVertices = 0;
	<span class="reserved">this</span>.dft(vertices.get(0));
	<span class="reserved">return</span> (<span class="reserved">this</span>.numberOfMarkedVertices == <span class="reserved">this</span>.numberOfVertices);
}

uwm.diagram.autolayout.Graph.<span class="reserved">prototype</span>.dft = <span class="reserved">function</span>(v) {
	v.booleanField = true;
	++<span class="reserved">this</span>.numberOfMarkedVertices;
	<span class="reserved">for</span> (var i = 0; i &lt; v.undirectedDegree; i++) {
		var neighbor = v.undirectedNeighbors.get(i);
		<span class="reserved">if</span> (!neighbor.booleanField) {
			<span class="reserved">this</span>.dft(neighbor);
		}
	}
	<span class="reserved">for</span> (var i = 0; i &lt; v.undirectedDegree; i++) {
		var neighbor = v.inNeighbors.get(i);
		<span class="reserved">if</span> (!neighbor.booleanField) {
			<span class="reserved">this</span>.dft(neighbor);
		}
	}
	<span class="reserved">for</span> (var i = 0; i &lt; v.undirectedDegree; i++) {
		var neighbor = v.outNeighbors.get(i);
		<span class="reserved">if</span> (!neighbor.booleanField) {
			<span class="reserved">this</span>.dft(neighbor);
		}
	}
}

<span class="comment">///VertexEdgeRepulsionLaw</span>

uwm.diagram.autolayout.VertexEdgeRepulsionLaw = <span class="reserved">function</span>(graph, preferredEdgeLength, strength) {
	uwm.diagram.autolayout.ForceLaw.call(<span class="reserved">this</span>, graph);
	
	<span class="reserved">this</span>.preferredEdgeLength = preferredEdgeLength;
	<span class="reserved">this</span>.strength = 1;
	
	<span class="reserved">this</span>.gridding = false;
	
	<span class="reserved">if</span> (strength) {
		<span class="reserved">this</span>.strength = strength;
	}
}
uwm.diagram.autolayout.VertexEdgeRepulsionLaw.<span class="reserved">prototype</span> = new uwm.diagram.autolayout.ForceLaw;

uwm.diagram.autolayout.VertexEdgeRepulsionLaw.<span class="reserved">prototype</span>.getGridding = <span class="reserved">function</span>() {
	<span class="reserved">return</span> gridding;
}

uwm.diagram.autolayout.VertexEdgeRepulsionLaw.<span class="reserved">prototype</span>.setGridding = <span class="reserved">function</span>(b) {
	<span class="reserved">this</span>.gridding = b;
}

uwm.diagram.autolayout.VertexEdgeRepulsionLaw.<span class="reserved">prototype</span>.apply = <span class="reserved">function</span>(negativeGradient) {
	<span class="reserved">if</span> (<span class="reserved">this</span>.gridding) {
		<span class="reserved">this</span>.applyUsingGridding(negativeGradient);
	}
	var n = <span class="reserved">this</span>.graph.numberOfVertices;
	var m = <span class="reserved">this</span>.graph.numberOfEdges;
	var d = <span class="reserved">this</span>.graph.getDimensions();
	<span class="reserved">for</span> (var i = 0; i &lt; n; i++) {
		var v = <span class="reserved">this</span>.graph.vertices.get(i);
		<span class="reserved">for</span> (var j = 0; j &lt; m; j++) {
			var e = <span class="reserved">this</span>.graph.edges.get(j);
			var from = e.getFrom();
			var to = e.getTo();
			<span class="reserved">this</span>.computeRepulsion(v, e, negativeGradient);
		}
	}
}

uwm.diagram.autolayout.VertexEdgeRepulsionLaw.<span class="reserved">prototype</span>.applyUsingGridding = <span class="reserved">function</span>(negativeGradient) {
	<span class="reserved">this</span>.graph.recomputeBoundaries();
	var n = <span class="reserved">this</span>.graph.numberOfVertices;
	var m = <span class="reserved">this</span>.graph.numberOfEdges;
	var d = <span class="reserved">this</span>.graph.getDimensions();
	var gridSize = new Array();
	var drawingArea = <span class="reserved">this</span>.graph.getSize();
	var k = <span class="reserved">this</span>.preferredEdgeLength;
	<span class="reserved">for</span> (var i = 0; i &lt; d; i++) {
		gridSize[i] = parseInt(drawingArea[i] / k) + 1;
	}
	var grid = new draw2d.ArrayList();
	var gMin = <span class="reserved">this</span>.graph.getMin();
	var index = new Array();
	var sign = new Array();
	<span class="reserved">for</span> (var i = 0; i &lt; n; i++) {
		var v = <span class="reserved">this</span>.graph.vertices.get(i);
		var c = v.getCoords();
		<span class="reserved">for</span> (var j = 0; j &lt; d; j++) {
			index[j] = parseInt((c[j] - gMin[j]) / k);
		}
		var gridCell = grid.get(index);
		<span class="reserved">if</span> (gridCell == null) {
			grid.insertElementAt(new draw2d.ArrayList(), index);
		}
		<span class="reserved">else</span> {
			gridCell.add(v);
		}
		v.objectField = index;
	}
	<span class="reserved">for</span> (var i = 0; i &lt; m; i++) {
		var e = <span class="reserved">this</span>.graph.edges.get(i);
		var from = e.getFrom();
		var to = e.getTo();
		var fCoords = from.getCoords();
		var tCoords = to.getCoords();
		<span class="reserved">for</span> (var j = 0; j &lt; d; j++) {
			<span class="reserved">if</span> (fCoords[j] &lt; tCoords[j]) {
				sign[j] = 1;
			}
			<span class="reserved">else</span> <span class="reserved">if</span> (fCoords[j] &gt; tCoords[j]) {
				sign[j] = -1;
			}
			<span class="reserved">else</span> {
				sign[j] = 0;
			}
		}
		var current = from.objectField;
		var numberOfAdjs = <span class="reserved">this</span>.power(3, d);
		var flag = true;
		<span class="reserved">while</span> (flag || (!<span class="reserved">this</span>.equal(current, to.objectField))) {
			flag = false;
			<span class="reserved">for</span> (var adj = 0; adj &lt; numberOfAdjs; adj++) {
				var temp = adj;
				var doSecondPart = true;
				<span class="reserved">for</span> (var j = 0; j &lt; d; j++) {
					index[j] = current[j] + (temp % 3) - 1;
					<span class="reserved">if</span> ((index[j] &lt; 0) || (index[j] &gt;= gridSize[j])) {
						doSecondPart = false
						temp /= 3;
					}
				}
				<span class="reserved">if</span> (doSecondPart) {
					var gridCell = grid.get(index);
					<span class="reserved">if</span> ((gridCell != null) &amp;&amp; (!gridCell.booleanField)) {
						<span class="reserved">for</span> (var en = 0; en &lt; gridCell.length; en++) {
							var v = gridCell[en];
							<span class="reserved">this</span>.computeRepulsion(v, e, negativeGradient);
						}
						gridCell.booleanField = true;
					}
				}
			}
			var time;
			var minTime = Number.MAX_VALUE;
			var nextAxis = 0;
			<span class="reserved">for</span> (var axis = 0; axis &lt; d; axis++) {
				<span class="reserved">if</span> (sign[axis] == 0) {
					continue;
				}
				<span class="reserved">if</span> (sign[axis] == 1) {
					time = (current[axis] + 1) * k /
					(tCoords[axis] - fCoords[axis]);
				}
				<span class="reserved">else</span> {
					time = current[axis] * k /
					(fCoords[axis] - tCoords[axis]);
				}
				<span class="reserved">if</span> (time &lt; minTime) {
					minTime = time;
					nextAxis = axis;
				}
			}
			current[nextAxis] += sign[nextAxis];
		}
	}
}

uwm.diagram.autolayout.VertexEdgeRepulsionLaw.<span class="reserved">prototype</span>.equal = <span class="reserved">function</span>(u, v) {
	var d = u.length;
	<span class="reserved">for</span> (var i = 0; i &lt; d; i++) {
		<span class="reserved">if</span> (u[i] != v[i]) {
			<span class="reserved">return</span> false;
		}
	}
	<span class="reserved">return</span> true;
}

uwm.diagram.autolayout.VertexEdgeRepulsionLaw.<span class="reserved">prototype</span>.computeRepulsion = <span class="reserved">function</span>(v, e, negativeGradient) {
	var from = e.getFrom();
	var to = e.getTo();
	<span class="reserved">if</span> ((from == v) || (to == v)) {
		<span class="reserved">return</span>;
	}
	var d = v.getDimensions();
	var vCoords = v.getCoords();
	var fCoords = from.getCoords();
	var tCoords = to.getCoords();
	var dp = 0;
	var lenSquared;
	<span class="reserved">for</span> (var i = 0; i &lt; d; i++) {
		dp += (vCoords[i] - fCoords[i]) * (tCoords[i] - fCoords[i]);
	}
	<span class="reserved">if</span> (dp &lt;= 0) {
		<span class="reserved">this</span>.computeRepulsionVertex(v, from, negativeGradient);
	}
	<span class="reserved">else</span> <span class="reserved">if</span> (dp &gt;= (lenSquared = e.getLengthSquared())) {
		<span class="reserved">this</span>.computeRepulsionVertex(v, to, negativeGradient);
	}
	<span class="reserved">else</span> {
		var len = Math.sqrt(lenSquared);
		var alpha = dp / len;
		var pCoords = new Array();
		<span class="reserved">for</span> (var i = 0; i &lt; d; i++) {
			pCoords[i] = (1 - alpha) * fCoords[i] + alpha * tCoords[i];
		}
		var w = Math.min(<span class="reserved">this</span>.strength * <span class="reserved">this</span>.pairwiseRepulsionCoords(v, pCoords), <span class="reserved">this</span>.cap / uwm.diagram.autolayout.Vertex.<span class="reserved">prototype</span>.getDistancePoint(v, pCoords));
		<span class="reserved">if</span> (w == 0) {
			<span class="reserved">return</span>;
		}
		var vWeight = v.getWeight();
		var fWeight = from.getWeight();
		var tWeight = to.getWeight();
		<span class="reserved">for</span> (var i = 0; i &lt; d; i++) {
			var force1 = (vCoords[i] - fCoords[i]) * w * (1 - alpha);
			var force2 = (vCoords[i] - tCoords[i]) * w * alpha;
			negativeGradient[v.intField][i] += force1 * fWeight;
			negativeGradient[from.intField][i] -= force1 * vWeight;
			negativeGradient[v.intField][i] += force2 * tWeight;
			negativeGradient[to.intField][i] -= force2 * vWeight;
		}
	}
}

uwm.diagram.autolayout.VertexEdgeRepulsionLaw.<span class="reserved">prototype</span>.computeRepulsionVertex = <span class="reserved">function</span>(v1, v2, negativeGradient) {
	var d = v1.getDimensions();
	var w = Math.min(<span class="reserved">this</span>.strength * <span class="reserved">this</span>.pairwiseRepulsion(v1, v2), <span class="reserved">this</span>.cap / uwm.diagram.autolayout.Vertex.<span class="reserved">prototype</span>.getDistance(v1, v2));
	<span class="reserved">if</span> (w == 0) {
		<span class="reserved">return</span>;
	}
	var v1Coords = v1.getCoords();
	var weight1 = v1.getWeight();
	var v2Coords = v2.getCoords();
	var weight2 = v2.getWeight();
	<span class="reserved">for</span> (var i = 0; i &lt; d; i++) {
		var force = (v1Coords[i] - v2Coords[i]) * w;
		negativeGradient[v1.intField][i] += force * weight2;
		negativeGradient[v2.intField][i] -= force * weight1;
	}
}

<span class="comment">///InverseSquareVertexEdgeRepulsionLaw</span>

uwm.diagram.autolayout.InverseSquareVertexEdgeRepulsionLaw = <span class="reserved">function</span>(graph, preferredEdgeLength, strength) {
	<span class="reserved">if</span> (!strength) {
		strength = 1;
	}
	
	uwm.diagram.autolayout.VertexEdgeRepulsionLaw.call(<span class="reserved">this</span>, graph, preferredEdgeLength, strength);
}

uwm.diagram.autolayout.InverseSquareVertexEdgeRepulsionLaw.<span class="reserved">prototype</span> = new uwm.diagram.autolayout.VertexEdgeRepulsionLaw;

uwm.diagram.autolayout.InverseSquareVertexEdgeRepulsionLaw.<span class="reserved">prototype</span>.pairwiseRepulsion = <span class="reserved">function</span>(c1, c2) {
	var k = <span class="reserved">this</span>.preferredEdgeLength + uwm.diagram.autolayout.Cell.<span class="reserved">prototype</span>.sumOfRadii(c1, c2);
	var d = uwm.diagram.autolayout.Cell.<span class="reserved">prototype</span>.getDistance(c1, c2);
	<span class="reserved">if</span> (d &gt;= k) {
		<span class="reserved">return</span> 0;
	}
	<span class="reserved">else</span> {
		<span class="reserved">return</span> <span class="reserved">this</span>.cube(k / d) - k / d;
	}
}

uwm.diagram.autolayout.InverseSquareVertexEdgeRepulsionLaw.<span class="reserved">prototype</span>.pairwiseRepulsionCoords = <span class="reserved">function</span>(cell, coords) {
	var k = <span class="reserved">this</span>.preferredEdgeLength + uwm.diagram.autolayout.Cell.<span class="reserved">prototype</span>.radius(cell, coords);
	var d = uwm.diagram.autolayout.Cell.<span class="reserved">prototype</span>.getDistancePoint(cell, coords);
	<span class="reserved">if</span> (d &gt;= k) {
		<span class="reserved">return</span> 0;
	}
	<span class="reserved">else</span> {
		<span class="reserved">return</span> <span class="reserved">this</span>.cube(k / d) - k / d;
	}
}

<span class="comment">///InverseSquareVertexVertexRepulsionLaw</span>

uwm.diagram.autolayout.InverseSquareVertexVertexRepulsionLaw = <span class="reserved">function</span>(graph, preferredEdgeLength) {
	uwm.diagram.autolayout.VertexVertexRepulsionLaw.call(<span class="reserved">this</span>, graph, preferredEdgeLength);
}

uwm.diagram.autolayout.InverseSquareVertexVertexRepulsionLaw.<span class="reserved">prototype</span> = new uwm.diagram.autolayout.VertexVertexRepulsionLaw;

uwm.diagram.autolayout.InverseSquareVertexVertexRepulsionLaw.<span class="reserved">prototype</span>.pairwiseRepulsion = <span class="reserved">function</span>(c1, c2) {
	var k = <span class="reserved">this</span>.preferredEdgeLength + uwm.diagram.autolayout.Cell.<span class="reserved">prototype</span>.sumOfRadii(c1, c2);
	<span class="reserved">return</span> <span class="reserved">this</span>.cube(k / uwm.diagram.autolayout.Cell.<span class="reserved">prototype</span>.getDistance(c1, c2));
}

<span class="comment">///InverseVertexEdgeRepulsionLaw</span>

uwm.diagram.autolayout.InverseVertexEdgeRepulsionLaw = <span class="reserved">function</span>(graph, preferredEdgeLength, strength) {
	<span class="reserved">if</span> (!strength) {
		strength = 1;
	}
	
	uwm.diagram.autolayout.VertexEdgeRepulsionLaw.call(<span class="reserved">this</span>, graph, preferredEdgeLength, strength);
}

uwm.diagram.autolayout.InverseVertexEdgeRepulsionLaw.<span class="reserved">prototype</span> = new uwm.diagram.autolayout.VertexEdgeRepulsionLaw;

uwm.diagram.autolayout.InverseVertexEdgeRepulsionLaw.<span class="reserved">prototype</span>.pairwiseRepulsion = <span class="reserved">function</span>(c1, c2) {
	var k = <span class="reserved">this</span>.preferredEdgeLength + uwm.diagram.autolayout.Cell.<span class="reserved">prototype</span>.sumOfRadii(c1, c2);
	var dSquared = uwm.diagram.autolayout.Cell.<span class="reserved">prototype</span>.getDistanceSquared(c1, c2);
	<span class="reserved">if</span> (dSquared &gt;= <span class="reserved">this</span>.square(k)) {
		<span class="reserved">return</span> 0;
	}
	<span class="reserved">else</span> {
		<span class="reserved">return</span> k * k / dSquared - k / Math.sqrt(dSquared);
	}
}

uwm.diagram.autolayout.InverseVertexEdgeRepulsionLaw.<span class="reserved">prototype</span>.pairwiseRepulsionCoords = <span class="reserved">function</span>(cell, coords) {
	var k = <span class="reserved">this</span>.preferredEdgeLength + uwm.diagram.autolayout.Cell.<span class="reserved">prototype</span>.radius(cell, coords);
	var dSquared = uwm.diagram.autolayout.Cell.<span class="reserved">prototype</span>.getDistanceSquaredPoint(cell, coords);
	<span class="reserved">if</span> (dSquared &gt;= <span class="reserved">this</span>.square(k)) {
		<span class="reserved">return</span> 0;
	}
	<span class="reserved">else</span> {
		<span class="reserved">return</span> k * k / dSquared - k / Math.sqrt(dSquared);
	}
}

<span class="comment">///InverseVertexVertexRepulsionLaw</span>

uwm.diagram.autolayout.InverseVertexVertexRepulsionLaw = <span class="reserved">function</span>(graph, preferredEdgeLength) {
	uwm.diagram.autolayout.VertexVertexRepulsionLaw.call(<span class="reserved">this</span>, graph, preferredEdgeLength);
}

uwm.diagram.autolayout.InverseVertexVertexRepulsionLaw.<span class="reserved">prototype</span> = new uwm.diagram.autolayout.VertexVertexRepulsionLaw;

uwm.diagram.autolayout.InverseVertexVertexRepulsionLaw.<span class="reserved">prototype</span>.pairwiseRepulsion = <span class="reserved">function</span>(c1, c2) {
	var k = <span class="reserved">this</span>.preferredEdgeLength + uwm.diagram.autolayout.Cell.<span class="reserved">prototype</span>.sumOfRadii(c1, c2);
	<span class="reserved">return</span> k * k / uwm.diagram.autolayout.Cell.<span class="reserved">prototype</span>.getDistanceSquared(c1, c2);
}

<span class="comment">///LinearSpringLaw</span>

uwm.diagram.autolayout.LinearSpringLaw = <span class="reserved">function</span>(graph, preferredEdgeLength) {
	uwm.diagram.autolayout.SpringLaw.call(<span class="reserved">this</span>, graph, preferredEdgeLength);
}

uwm.diagram.autolayout.LinearSpringLaw.<span class="reserved">prototype</span> = new uwm.diagram.autolayout.SpringLaw;

uwm.diagram.autolayout.LinearSpringLaw.<span class="reserved">prototype</span>.springAttraction = <span class="reserved">function</span>(e) {
	var r = uwm.diagram.autolayout.Cell.<span class="reserved">prototype</span>.sumOfRadii(e.getFrom(), e.getTo());
	<span class="reserved">if</span> (r == 0) {
		<span class="reserved">return</span> 1;
	}
	<span class="reserved">else</span> {
		<span class="reserved">return</span> 1 - r / e.getLength();
	}
}

<span class="comment">///StandardForceModel</span>

<span class="comment">/** Class for standard force model of graph-drawing aesthetics. */</span>

uwm.diagram.autolayout.StandardForceModel = <span class="reserved">function</span>(graph, preferredEdgeLength, theta) {
	uwm.diagram.autolayout.ForceModel.call(<span class="reserved">this</span>, graph);
	<span class="reserved">this</span>.preferredEdgeLength = preferredEdgeLength;
	var springLaw = new uwm.diagram.autolayout.QuadraticSpringLaw(graph, preferredEdgeLength);
	var vvRepulsionLaw = new uwm.diagram.autolayout.HybridVertexVertexRepulsionLaw(graph, preferredEdgeLength);
	<span class="reserved">this</span>.addForceLaw(springLaw);
	<span class="reserved">this</span>.addForceLaw(vvRepulsionLaw);
	<span class="reserved">this</span>.addConstraint(new uwm.diagram.autolayout.ProjectionConstraint(graph, 2));
}

<span class="comment">///SteepestDescent</span>

<span class="comment">/** Class for method of steepest descent. */</span>

uwm.diagram.autolayout.SteepestDescent = <span class="reserved">function</span>(graph, fm, accuracy) {
	uwm.diagram.autolayout.FirstOrderOptimizationProcedure.call(<span class="reserved">this</span>, graph, fm, accuracy);
}

uwm.diagram.autolayout.SteepestDescent.<span class="reserved">prototype</span> = new uwm.diagram.autolayout.FirstOrderOptimizationProcedure;

uwm.diagram.autolayout.SteepestDescent.<span class="reserved">prototype</span>.computeDescentDirection = <span class="reserved">function</span>() {
	var n = <span class="reserved">this</span>.graph.numberOfVertices;
	var d = <span class="reserved">this</span>.graph.getDimensions();
	<span class="reserved">if</span> ((<span class="reserved">this</span>.descentDirection == null) || (<span class="reserved">this</span>.descentDirection.length != n)) {
		<span class="reserved">this</span>.descentDirection = new Array();
		<span class="reserved">for</span> (var i = 0; i &lt; n; i++) {
			<span class="reserved">this</span>.descentDirection[i] = new Array();
		}
	}
	
	<span class="reserved">for</span> (var i = 0; i &lt; n; i++) {
		<span class="reserved">for</span> (var j = 0; j &lt; d; j++) {
			<span class="reserved">this</span>.descentDirection[i][j] = <span class="reserved">this</span>.negativeGradient[i][j];
		}
	}
}


<span class="comment">///doLayout</span>

uwm.diagram.autolayout.Layouter = <span class="reserved">function</span>(workflow) {
	<span class="reserved">this</span>.workflow = workflow;
	<span class="reserved">this</span>.dimensions = 2;
	<span class="reserved">this</span>.preferredEdgeLength = 100;
	<span class="reserved">this</span>.optimizationProcedure = uwm.diagram.autolayout.Layouter.opt.CONJUGATE_GRADIENTS;
	<span class="reserved">this</span>.lineSearchAccuracy = 0.5;
	<span class="reserved">this</span>.cgRestartThreshold = 0.2;
	<span class="reserved">this</span>.springs = uwm.diagram.autolayout.Layouter.spring.QUADRATIC;
	<span class="reserved">this</span>.vertexVertexRepulsion = uwm.diagram.autolayout.Layouter.vvRepulsion.INVERSE_SQUARE;
	<span class="reserved">this</span>.gridding = false;
	<span class="reserved">this</span>.barnesHut = false;
	<span class="reserved">this</span>.theta = 0.9;
	<span class="reserved">this</span>.iterations = 25;
}

uwm.diagram.autolayout.Layouter.opt = {
	CONJUGATE_GRADIENTS: uwm.diagram.autolayout.ConjugateGradients,
	STEEPEST_DESCENT: uwm.diagram.autolayout.SteepestDescent
};

uwm.diagram.autolayout.Layouter.spring = {
	QUADRATIC: uwm.diagram.autolayout.QuadraticSpringLaw,
	LINEAR: uwm.diagram.autolayout.LinearSpringLaw
};

uwm.diagram.autolayout.Layouter.vvRepulsion = {
	INVERSE_SQUARE: uwm.diagram.autolayout.InverseSquareVertexVertexRepulsionLaw,
	INVERSE: uwm.diagram.autolayout.InverseVertexVertexRepulsionLaw,
	HYBRID: uwm.diagram.autolayout.HybridVertexVertexRepulsionLaw,
	INVERSE_SQUARE_EDGE: uwm.diagram.autolayout.InverseSquareVertexEdgeRepulsionLaw,
	INVERSE_EDGE: uwm.diagram.autolayout.InverseVertexEdgeRepulsionLaw
}

uwm.diagram.autolayout.Layouter.<span class="reserved">prototype</span>.getDimensions = <span class="reserved">function</span>() {
	<span class="reserved">return</span> <span class="reserved">this</span>.dimensions;
}

uwm.diagram.autolayout.Layouter.<span class="reserved">prototype</span>.setDimenstion = <span class="reserved">function</span>(d) {
	<span class="reserved">this</span>.dimensions = d;
}

uwm.diagram.autolayout.Layouter.<span class="reserved">prototype</span>.getPreferredEdgeLength = <span class="reserved">function</span>() {
	<span class="reserved">return</span> <span class="reserved">this</span>.preferredEdgeLength;
}

uwm.diagram.autolayout.Layouter.<span class="reserved">prototype</span>.setPreferredEdgeLength = <span class="reserved">function</span>(k) {
	<span class="reserved">this</span>.preferredEdgeLength = k;
}

uwm.diagram.autolayout.Layouter.<span class="reserved">prototype</span>.getOptimizationProcedure = <span class="reserved">function</span>() {
	<span class="reserved">return</span> <span class="reserved">this</span>.optimizationProcedure;
}

uwm.diagram.autolayout.Layouter.<span class="reserved">prototype</span>.setOptimizationProcedure = <span class="reserved">function</span>(o) {
	<span class="reserved">this</span>.optimizationProcedure = o;
}

uwm.diagram.autolayout.Layouter.<span class="reserved">prototype</span>.getLineSearchAccuracy = <span class="reserved">function</span>() {
	<span class="reserved">return</span> <span class="reserved">this</span>.lineSearchAccuracy;
}

uwm.diagram.autolayout.Layouter.<span class="reserved">prototype</span>.setLineSearchAccuracy = <span class="reserved">function</span>(l) {
	<span class="reserved">this</span>.lineSearchAccuracy = l;
}

uwm.diagram.autolayout.Layouter.<span class="reserved">prototype</span>.getCgRestartThreshold = <span class="reserved">function</span>() {
	<span class="reserved">return</span> <span class="reserved">this</span>.cgRestartThreshold;
}

uwm.diagram.autolayout.Layouter.<span class="reserved">prototype</span>.setCgRestartThreshold = <span class="reserved">function</span>(c) {
	<span class="reserved">this</span>.cgRestartThreshold = c;
}

uwm.diagram.autolayout.Layouter.<span class="reserved">prototype</span>.getSprings = <span class="reserved">function</span>() {
	<span class="reserved">return</span> <span class="reserved">this</span>.springs;
}

uwm.diagram.autolayout.Layouter.<span class="reserved">prototype</span>.setSprings = <span class="reserved">function</span>(s) {
	<span class="reserved">this</span>.springs = s;
}

uwm.diagram.autolayout.Layouter.<span class="reserved">prototype</span>.getVertexVertexRepulsion = <span class="reserved">function</span>() {
	<span class="reserved">return</span> <span class="reserved">this</span>.vertexVertexRepulsion;
}

uwm.diagram.autolayout.Layouter.<span class="reserved">prototype</span>.setVertexVertexRepulsion = <span class="reserved">function</span>(v) {
	<span class="reserved">this</span>.vertexVertexRepulsion = v;
}

uwm.diagram.autolayout.Layouter.<span class="reserved">prototype</span>.getGridding = <span class="reserved">function</span>() {
	<span class="reserved">return</span> <span class="reserved">this</span>.gridding;
}

uwm.diagram.autolayout.Layouter.<span class="reserved">prototype</span>.setGridding = <span class="reserved">function</span>(u) {
	<span class="reserved">this</span>.gridding = u;
}

uwm.diagram.autolayout.Layouter.<span class="reserved">prototype</span>.getBarnesHut = <span class="reserved">function</span>() {
	<span class="reserved">return</span> <span class="reserved">this</span>.barnesHut;
}

uwm.diagram.autolayout.Layouter.<span class="reserved">prototype</span>.setBarnesHut = <span class="reserved">function</span>(b) {
	<span class="reserved">this</span>.barnesHut = b;
}

uwm.diagram.autolayout.Layouter.<span class="reserved">prototype</span>.getTheta = <span class="reserved">function</span>() {
	<span class="reserved">return</span> <span class="reserved">this</span>.theta;
}

uwm.diagram.autolayout.Layouter.<span class="reserved">prototype</span>.setTheta = <span class="reserved">function</span>(t) {
	<span class="reserved">this</span>.theta = t;
}

uwm.diagram.autolayout.Layouter.<span class="reserved">prototype</span>.getIterations = <span class="reserved">function</span>() {
	<span class="reserved">return</span> <span class="reserved">this</span>.iterations;
}

uwm.diagram.autolayout.Layouter.<span class="reserved">prototype</span>.setIterations = <span class="reserved">function</span>(i) {
	<span class="reserved">this</span>.iterations = i;
}

uwm.diagram.autolayout.Layouter.<span class="reserved">prototype</span>.doLayout = <span class="reserved">function</span>() {
	<span class="reserved">this</span>.setupGraph();
	<span class="reserved">this</span>.setupAndExecuteOptimization();
	<span class="reserved">this</span>.moveFigures();
}

uwm.diagram.autolayout.Layouter.<span class="reserved">prototype</span>.setupGraph = <span class="reserved">function</span>() {
	<span class="reserved">this</span>.graph = new uwm.diagram.autolayout.Graph(<span class="reserved">this</span>.dimensions);
	
	<span class="reserved">this</span>.graph.setSize([<span class="reserved">this</span>.workflow.getWidth(), <span class="reserved">this</span>.workflow.getHeight()]);
	
	<span class="reserved">this</span>.figures = <span class="reserved">this</span>.workflow.getFigures();
	<span class="reserved">this</span>.vertexes = new draw2d.ArrayList();
	<span class="reserved">for</span> (var i = 0; i &lt; <span class="reserved">this</span>.figures.getSize(); i++) {
		var figure = <span class="reserved">this</span>.figures.get(i);
		var vertex = <span class="reserved">this</span>.graph.insertVertex();
		vertex.setName(figure.getId());
		vertex.setCoords([figure.getX(), figure.getY()]);
		vertex.setSize([figure.getWidth(), figure.getHeight()]);
		<span class="reserved">this</span>.vertexes.add(vertex);
	}
	
	var clusterIds = new Array();
	var nextClusterId = 1;
	
	var clusters = new Array();
	
	<span class="reserved">for</span> (var i = 0; i &lt; <span class="reserved">this</span>.figures.getSize(); i++) {
		<span class="reserved">if</span> (!clusterIds[i]) {
			<span class="reserved">this</span>.walkAndPopulateClusters(i, clusterIds, nextClusterId);
			nextClusterId++;
		}
		
		var figure = <span class="reserved">this</span>.figures.get(i);
		var ports = figure.getPorts();
		var numConnections = 0;
		<span class="reserved">for</span> (var j = 0; j &lt; ports.getSize(); j++) {
			var port = ports.get(j);
			var connections = port.getConnections();
			<span class="reserved">for</span> (var k = 0; k &lt; connections.getSize(); k++) {
				numConnections++;
				
				var connection = connections.get(k);
				<span class="reserved">if</span> (connection.getSource() == port) {
					var from = <span class="reserved">this</span>.vertexes.get(i);
					var targetPort = connection.getTarget();
					var targetFigure = targetPort.getParent();
					var targetIndex = <span class="reserved">this</span>.figures.indexOf(targetFigure);
					var to = <span class="reserved">this</span>.vertexes.get(targetIndex)
					var edge = <span class="reserved">this</span>.graph.insertEdge(from, to, true);
				}
			}
		}
		var clustersEntry = clusters[clusterIds[i]];
		<span class="reserved">if</span> (clustersEntry) {
			<span class="reserved">if</span> (clustersEntry.maxConnections &lt; numConnections) {
				clustersEntry.maxConnections = numConnections;
				clustersEntry.vertex = <span class="reserved">this</span>.vertexes.get(i);
			}
		}
		<span class="reserved">else</span> {
			clusters[clusterIds[i]] = {
				maxConnections: numConnections,
				vertex: <span class="reserved">this</span>.vertexes.get(i)
			};
		}
	}
	
	<span class="reserved">for</span> (var i = 1; i &lt; clusters.length; i++) {
		<span class="reserved">if</span> (i != 1) {
			var from = clusters[i - 1].vertex;
			var to = clusters[i].vertex;
			var edge = <span class="reserved">this</span>.graph.insertEdge(from, to, false);
		}
		<span class="reserved">else</span> {
			var from = clusters[clusters.length - 1].vertex;
			var to = clusters[1].vertex;
			var edge = <span class="reserved">this</span>.graph.insertEdge(from, to, false);
		}
	}
	
}

uwm.diagram.autolayout.Layouter.<span class="reserved">prototype</span>.setupAndExecuteOptimization = <span class="reserved">function</span>() {
	var springLaw = new <span class="reserved">this</span>.springs(<span class="reserved">this</span>.graph, <span class="reserved">this</span>.preferredEdgeLength);
	
	var vvRepulsionLaw = new <span class="reserved">this</span>.vertexVertexRepulsion(<span class="reserved">this</span>.graph, <span class="reserved">this</span>.preferredEdgeLength);
	
	<span class="reserved">if</span> (vvRepulsionLaw instanceof uwm.diagram.autolayout.VertexVertexRepulsionLaw &amp;&amp; <span class="reserved">this</span>.barnesHut) {
		vvRepulsionLaw.setBarnesHutTheta(<span class="reserved">this</span>.theta);
	}
	
	<span class="reserved">if</span> (vvRepulsionLaw instanceof uwm.diagram.autolayout.VertexEdgeRepulsionLaw) {
		vvRepulsionLaw.setGridding(<span class="reserved">this</span>.gridding);
	}
	
	
	var forceModel = new uwm.diagram.autolayout.ForceModel(<span class="reserved">this</span>.graph);
	forceModel.addForceLaw(springLaw);
	forceModel.addForceLaw(vvRepulsionLaw);
	
	<span class="reserved">if</span> (<span class="reserved">this</span>.dimensions &gt; 0) {
		forceModel.addConstraint(new uwm.diagram.autolayout.ProjectionConstraint(<span class="reserved">this</span>.graph, <span class="reserved">this</span>.dimensions));
	}
	
	var opt = new <span class="reserved">this</span>.optimizationProcedure(<span class="reserved">this</span>.graph, forceModel, <span class="reserved">this</span>.lineSearchAccuracy, <span class="reserved">this</span>.cgRestartThreshold);
	
	<span class="reserved">for</span> (var i = 0; i &lt; <span class="reserved">this</span>.iterations; i++) {
		opt.improveGraph();
	}
}

uwm.diagram.autolayout.Layouter.<span class="reserved">prototype</span>.moveFigures = <span class="reserved">function</span>() {
	<span class="reserved">for</span> (var i = 0; i &lt; <span class="reserved">this</span>.vertexes.getSize(); i++) {
		var vertex = <span class="reserved">this</span>.vertexes.get(i);
		var figure = <span class="reserved">this</span>.figures.get(i);
		
		var coords = vertex.getCoords();

		var command = new draw2d.CommandMove(figure);
		command.setPosition(parseInt(coords[0]), parseInt(coords[1]));

		<span class="reserved">this</span>.workflow.getCommandStack().execute(command);
	}
}

uwm.diagram.autolayout.Layouter.<span class="reserved">prototype</span>.walkAndPopulateClusters = <span class="reserved">function</span>(index, clusterIds, thisClusterId) {
	var figure = <span class="reserved">this</span>.figures.get(index);
	<span class="reserved">if</span> (!clusterIds[index]) {
		clusterIds[index] = thisClusterId;
		
		var ports = figure.getPorts();
		<span class="reserved">for</span> (var j = 0; j &lt; ports.getSize(); j++) {
			var port = ports.get(j);
			var connections = port.getConnections();
			<span class="reserved">for</span> (var k = 0; k &lt; connections.getSize(); k++) {
				var connection = connections.get(k);
				<span class="reserved">if</span> (connection.getSource() == port) {
					var targetPort = connection.getTarget();
					var targetFigure = targetPort.getParent();
					var targetIndex = <span class="reserved">this</span>.figures.indexOf(targetFigure);
					<span class="reserved">this</span>.walkAndPopulateClusters(targetIndex, clusterIds, thisClusterId);
				}
				<span class="reserved">else</span> {
					var sourcePort = connection.getSource();
					var sourceFigure = sourcePort.getParent();
					var sourceIndex = <span class="reserved">this</span>.figures.indexOf(sourceFigure);
					<span class="reserved">this</span>.walkAndPopulateClusters(sourceIndex, clusterIds, thisClusterId);
				}
			}
		}
	}
}
</pre>
	<hr>



<!-- ========== START OF NAVBAR ========== -->
<a name="navbar_top"><!-- --></a>
<table border="0" width="100%" cellpadding="1" cellspacing="0">
<tr>
<td colspan=2 bgcolor="#EEEEFF" class="NavBarCell1">
<a name="navbar_top_firstrow"><!-- --></a>
<table border="0" cellpadding="0" cellspacing="3">
  <tr align="center" valign="top">
  
  
  <td bgcolor="#EEEEFF" class="NavBarCell1">    <a href="overview-summary.html"><font class="NavBarFont1"><b>Overview</b></font></a>&nbsp;</td>
  <td bgcolor="#FFFFFF" class="NavBarCell1Rev">	&nbsp;<font class="NavBarFont1Rev"><b>File</b></font>&nbsp;</td>
  

  <td bgcolor="#FFFFFF" class="NavBarCell1"> <font class="NavBarFont1">Class</font>&nbsp;</td>
  <td bgcolor="#EEEEFF" class="NavBarCell1">    <a href="overview-tree.html"><font class="NavBarFont1"><b>Tree</b></font></a>&nbsp;</td>
  <td bgcolor="#EEEEFF" class="NavBarCell1">    <a href="index-all.html"--><font class="NavBarFont1"><b>Index</b></font></a>&nbsp;</td>
  <td bgcolor="#EEEEFF" class="NavBarCell1">    <a href="help-doc.html"><font class="NavBarFont1"><b>Help</b></font></a>&nbsp;</td>
  </tr>
</table>
</td>
<td bgcolor="#EEEEFF" align="right" valign="top"><em>
<b>Chronos Web Modeler</b></em>
</td>
</tr>

<tr>
<td bgcolor="white" class="NavBarCell2"><font size="-2">
&nbsp;PREV&nbsp;
&nbsp;NEXT</font></td>
<td bgcolor="white" class="NavBarCell2"><font size="-2">
  <a href="index.html" target="_top"><b>FRAMES</b></a>  &nbsp;
&nbsp;<a href="overview-summary.html" target="_top"><b>NO FRAMES</b></a>
&nbsp;&nbsp;
<script>
  <!--
  if(window==top) {
    document.writeln('<A HREF="allclasses-noframe.html" TARGET=""><B>All Classes</B></A>');
  }
  //-->
</script>
<noscript>
<a href="allclasses-noframe.html" target=""><b>All Classes</b></a>
</noscript>
</font></td>
</tr>
</table>
<!-- =========== END OF NAVBAR =========== -->

<hr>
<font size="-1">

</font>
<div class="jsdoc_ctime">Documentation generated by <a href="http://jsdoc.sourceforge.net/" target="_parent">JSDoc</a> on Tue Feb 17 01:13:07 2009</div>
</body>
</html>
